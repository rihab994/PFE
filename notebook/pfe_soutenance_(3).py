# -*- coding: utf-8 -*-
"""PFE_soutenance_(3).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xhP9kmu2ue8DwK1o-FFfgXykY1xgR3Ke

üß† 1. Business Understanding
Contexte :
Tu travailles sur un projet d‚Äôanalyse du risque de cr√©dit bancaire, en particulier pour pr√©dire si un client rencontrera des difficult√©s de remboursement (variable cible TARGET).

Objectif :
Construire un mod√®le pr√©dictif pour identifier les clients √† risque, en s‚Äôappuyant sur des donn√©es historiques de pr√™ts.

Variable cible :
TARGET :

1 : Client en d√©faut de paiement

0 : Client sans incident

üìä 2. Data Understanding
‚úÖ Dimensions :
58030 lignes

116 colonnes

‚úÖ Exemples de variables :
NAME_CONTRACT_TYPE : type de pr√™t (cash, revolving)

CODE_GENDER, FLAG_OWN_CAR, FLAG_OWN_REALTY : donn√©es socio-d√©mographiques

AMT_INCOME_TOTAL, AMT_CREDIT_x, AMT_ANNUITY_x : donn√©es financi√®res

DAYS_FIRST_DUE, DAYS_LAST_DUE, etc. : informations temporelles

‚úÖ Qualit√© des donn√©es :
Plusieurs colonnes contiennent des valeurs manquantes (ex : DAYS_FIRST_DRAWING, DAYS_LAST_DUE)

Doublons potentiels √† v√©rifier (SK_ID_CURR n‚Äôest pas toujours unique)

Valeurs aberrantes √† explorer (365243 indique souvent une valeur manquante cod√©e)

üõ† 3. Data Preparation
√âtapes recommand√©es :

Nettoyage

Imputation des valeurs manquantes (par la m√©diane, moyenne, ou valeurs par d√©faut sp√©cifiques)

Suppression ou agr√©gation de doublons

Transformation

Encodage des variables cat√©gorielles (ex. : CODE_GENDER, NAME_INCOME_TYPE)

Normalisation/standardisation des variables num√©riques

Feature Engineering

Cr√©ation de ratios : AMT_CREDIT / AMT_INCOME_TOTAL

D√©tection de d√©riv√©s temporels : ex. AGE = -DAYS_BIRTH/365

Conversion des jours cod√©s en dates utilisables

S√©paration

Dataset divis√© en X (features) et y (cible : TARGET)

S√©paration en jeu d'entra√Ænement/test (ex. 80/20)

ü§ñ 4. Modeling
Approches recommand√©es :

R√©gression Logistique (baseline)

Random Forest ou XGBoost pour capter les non-lin√©arit√©s

LightGBM pour performance + vitesse

SMOTE / sur√©chantillonnage pour compenser le d√©s√©quilibre de classes

Validation crois√©e :

Stratified K-Fold (pr√©serve distribution de la variable cible)

üìà 5. Evaluation
M√©triques cl√©s :

ROC-AUC : meilleure pour √©valuer les performances globales

F1-score, Recall : important pour minimiser les faux n√©gatifs (ne pas laisser passer un mauvais payeur)

Courbe de gains : pour applications m√©tier

Interpr√©tabilit√© : SHAP values pour expliquer les d√©cisions des mod√®les complexes

# 1. Compr√©hension du m√©tier
**Contexte :**
* Vous travaillez sur un projet d‚Äôanalyse du risque de cr√©dit bancaire, dont l‚Äôobjectif est de pr√©dire si un client rencontrera des difficult√©s de remboursement.

**Objectif :**
* Construire un mod√®le pr√©dictif capable d‚Äôidentifier les clients √† risque √† partir de donn√©es historiques de pr√™ts.

Variable cible ‚Äì TARGET :

* 1 : Client en d√©faut de paiement

* 0 : Client sans incident de paiement

# 2. Compr√©hension des donn√©es
**Dimensions :**

* Nombre de lignes : 58 030

* Nombre de colonnes : 116

**Exemples de variables :**

* NAME_CONTRACT_TYPE : type de pr√™t (ex. pr√™t personnel, renouvelable)

* CODE_GENDER, FLAG_OWN_CAR, FLAG_OWN_REALTY : donn√©es socio-d√©mographiques

* AMT_INCOME_TOTAL, AMT_CREDIT_x, AMT_ANNUITY_x : donn√©es financi√®res

* DAYS_FIRST_DUE, DAYS_LAST_DUE, etc. : variables temporelles

**Qualit√© des donn√©es :**
* Plusieurs colonnes pr√©sentent des valeurs manquantes (ex. DAYS_FIRST_DRAWING, DAYS_LAST_DUE)

* V√©rification n√©cessaire des doublons (la cl√© SK_ID_CURR n‚Äôest pas toujours unique)

* Pr√©sence de valeurs aberrantes (ex. 365243, souvent utilis√©e pour coder une valeur manquante)

# 3. Pr√©paration des donn√©es

**√âtapes recommand√©es :**

1. üîπ Nettoyage :

* Imputation des valeurs manquantes (m√©diane, moyenne ou valeurs par d√©faut sp√©cifiques)

* Suppression ou regroupement des doublons √©ventuels

2. üîπ Transformation :

* Encodage des variables cat√©gorielles (ex. : CODE_GENDER, NAME_INCOME_TYPE)

* Normalisation ou standardisation des variables num√©riques

3. üîπ Feature Engineering :

* Cr√©ation de nouvelles variables :

    * Exemple : RATIO_CREDIT_INCOME = AMT_CREDIT / AMT_INCOME_TOTAL

* Transformation de variables temporelles :

    *   Exemple : AGE = -DAYS_BIRTH / 365

* Conversion des jours cod√©s en dates exploitables

4. üîπ S√©paration :

* S√©paration du jeu de donn√©es en :

     * X : variables explicatives

     * y : variable cible (TARGET)

* Division en jeu d'entra√Ænement et de test (ex. 80/20)

#4. Mod√©lisation

**Approches recommand√©es :**

* R√©gression logistique : mod√®le de base pour interpr√©tabilit√©

* Random Forest ou XGBoost : pour capturer les relations non lin√©aires

* LightGBM : pour de bonnes performances avec un temps de calcul r√©duit

* Traitement du d√©s√©quilibre de classes :

* Utilisation de techniques comme SMOTE ou sur√©chantillonnage

**Validation crois√©e :**

* Stratified K-Fold : conserve la distribution de la variable cible dans chaque pli

#5. √âvaluation du mod√®le

**M√©triques cl√©s :**

* ROC-AUC : mesure globale de la performance du mod√®le

* F1-score et Recall : essentiels pour minimiser les faux n√©gatifs (√©viter de classer un mauvais payeur comme bon)

* Courbe de gains : utile pour les applications m√©tier

**Interpr√©tabilit√© :**

* Utilisation des valeurs SHAP pour expliquer les pr√©dictions des mod√®les complexes
"""

!pip install optbinning #transformer des variables continues ou cat√©gorielles en groupes discrets
                        #tr√®s utile pour les mod√®les de score de cr√©dit (credit scoring)
                        #calcule des mesures comme l‚ÄôInformation Value (IV), le Weight of Evidence (WoE)
                        #aide √† transformer intelligemment des variables pour les mod√®les de machine learning, surtout en finance.

!pip install squarify #utilis√©e pour cr√©er des treemaps (ou cartes en mosa√Øque)
                      #Les treemaps permettent de repr√©senter des donn√©es hi√©rarchiques sous forme de rectangles proportionnels, tr√®s utiles pour :
                                               #montrer des proportions visuelles (ex. parts de march√©, r√©partition budg√©taire, etc.),
                                               #visualiser des jeux de donn√©es avec de nombreux √©l√©ments.
                      #est utilis√© pour des graphiques visuels o√π la taille des rectangles refl√®te la valeur des donn√©es.

# Commented out IPython magic to ensure Python compatibility.
# Libraries

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
import itertools
# %matplotlib inline
warnings.filterwarnings('ignore')
from sklearn.linear_model import LogisticRegression, LogisticRegressionCV
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, roc_auc_score,roc_curve, auc, confusion_matrix, ConfusionMatrixDisplay
from optbinning import OptimalBinning
from sklearn.model_selection import train_test_split, GridSearchCV, StratifiedKFold, cross_val_score
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.impute import SimpleImputer
from sklearn.pipeline import Pipeline
from imblearn.pipeline import Pipeline as ImbPipeline
from imblearn.over_sampling import SMOTE
from sklearn.compose import ColumnTransformer
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from xgboost import XGBClassifier
from lightgbm import LGBMClassifier

application_data = pd.read_csv(r'/content/application_data.csv')
previous_application = pd.read_csv(r'/content/previous_application.csv')
columns_description = pd.read_csv(r'/content/columns_description.csv',skiprows=1)

print ("application_data     :",application_data.shape)
print ("previous_application :",previous_application.shape)
print ("columns_description  :",columns_description.shape)

print("Types de donn√©es application_data :\n", application_data.dtypes.value_counts())
print ("Types de donn√©es previous_application :",previous_application.dtypes.value_counts())
print ("Types de donn√©es columns_description  :",columns_description.dtypes.value_counts())

print("Statistiques descriptives :")
display(previous_application.describe())
display(application_data.describe())

print("Nombre de valeurs uniques par colonne :")
print(application_data.nunique().sort_values(ascending=False))
print(previous_application.nunique().sort_values(ascending=False).head(10))

"""Percentage of Missing values in previous_application"""

# Calcul du pourcentage de valeurs manquantes par colonne
missing_pct = round(100 * (previous_application.isnull().sum() / len(previous_application)), 2)

# Cr√©ation d'un DataFrame pour le graphique
miss_previous_application = missing_pct.reset_index()
miss_previous_application.columns = ['column', 'missing_percentage']
miss_previous_application["type"] = "previous_application"

# Trier les colonnes par pourcentage manquant d√©croissant
miss_sorted = miss_previous_application.sort_values(by="missing_percentage", ascending=False)

# Style propre
sns.set(style="whitegrid")
plt.figure(figsize=(10, 12))

# Graphique en barres horizontales
barplot = sns.barplot(
    data=miss_sorted,
    y="column",
    x="missing_percentage",
    palette="flare"
)

# Affichage des pourcentages manuellement
for i in range(len(miss_sorted)):
    value = miss_sorted["missing_percentage"].iloc[i]
    column = miss_sorted["column"].iloc[i]
    plt.text(value + 1, i, f"{value:.1f}%", va='center', fontsize=8)

# Ligne seuil
plt.axvline(50, color='red', linestyle='--', linewidth=1, label='Seuil 50%')

# Titre et axes
plt.title("Valeurs Manquantes (%) - previous_application", fontsize=14)
plt.xlabel("Pourcentage de valeurs manquantes", fontsize=12)
plt.ylabel("Colonnes", fontsize=12)
plt.legend()
plt.tight_layout()

plt.show()

"""* Ce graphe met en √©vidence les colonnes ayant un fort taux de valeurs manquantes. Les colonnes d√©passant 50% devraient √™tre r√©√©valu√©es ou exclues du mod√®le. Cela aide √† d√©cider de la strat√©gie de traitement des donn√©es manquantes.
* Removing columns with missing values more than 50%

As per Industrial Standard, max Threshold limit can be between 40% to 50 % depending upon the data acquired in specific sector.

"""

previous_application=previous_application.drop([ 'AMT_DOWN_PAYMENT', 'RATE_DOWN_PAYMENT', 'RATE_INTEREST_PRIMARY',
       "RATE_INTEREST_PRIVILEGED"],axis=1)

# Calcul des pourcentages de valeurs manquantes
miss_previous_application = pd.DataFrame(
    (previous_application.isnull().sum()) * 100 / previous_application.shape[0]
).reset_index()
miss_previous_application.columns = ['column', 'missing_percentage']
miss_previous_application["type"] = "previous_application"

# Tri pour lisibilit√©
miss_previous_application = miss_previous_application.sort_values(by="missing_percentage", ascending=False)

# Cr√©ation du graphique
plt.figure(figsize=(18, 6))
sns.set_theme(style="whitegrid")

# Barplot avec couleur d√©pendant du pourcentage
colors = sns.color_palette("viridis", len(miss_previous_application))
bar = sns.barplot(
    x="column",
    y="missing_percentage",
    data=miss_previous_application,
    palette=colors
)

# Ajout des pourcentages sur les barres
for i, row in enumerate(miss_previous_application.itertuples()):
    bar.text(
        x=i,
        y=row.missing_percentage + 1,
        s=f"{row.missing_percentage:.1f}%",
        ha='center',
        va='bottom',
        fontsize=8,
        rotation=90
    )

# Ligne de seuil √† 50 %
plt.axhline(50, color='red', linestyle='--', linewidth=1, label='Seuil 50%')

# Titres et mise en forme
plt.xticks(rotation=90, fontsize=8)
plt.title("Pourcentage de valeurs manquantes - previous_application", fontsize=14)
plt.ylabel("Pourcentage (%)", fontsize=12)
plt.xlabel("Colonnes", fontsize=12)

bar.set_facecolor("#f7f7f7")
bar.figure.set_facecolor("#f0f0f0")
plt.legend().set_title("")
plt.tight_layout()
plt.show()

print(previous_application[['AMT_ANNUITY', 'AMT_GOODS_PRICE', 'NAME_TYPE_SUITE', 'CNT_PAYMENT',
                            'DAYS_FIRST_DRAWING', 'DAYS_FIRST_DUE', 'DAYS_LAST_DUE_1ST_VERSION',
                            'DAYS_LAST_DUE', 'DAYS_TERMINATION', 'NFLAG_INSURED_ON_APPROVAL']].isnull().sum())

previous_application[['AMT_ANNUITY', 'AMT_GOODS_PRICE', 'NAME_TYPE_SUITE', 'CNT_PAYMENT',
                            'DAYS_FIRST_DRAWING', 'DAYS_FIRST_DUE', 'DAYS_LAST_DUE_1ST_VERSION',
                            'DAYS_LAST_DUE', 'DAYS_TERMINATION', 'NFLAG_INSURED_ON_APPROVAL']].describe()

# Style esth√©tique
sns.set_theme(style="whitegrid", palette="muted")

# Colonnes num√©riques √† tracer
columns = ['AMT_ANNUITY', 'AMT_GOODS_PRICE', 'CNT_PAYMENT',
           'DAYS_FIRST_DRAWING', 'DAYS_FIRST_DUE', 'DAYS_LAST_DUE_1ST_VERSION',
           'DAYS_LAST_DUE', 'DAYS_TERMINATION', 'NFLAG_INSURED_ON_APPROVAL']

# Configuration de la grille
n_cols = 3
n_rows = (len(columns) + n_cols - 1) // n_cols

# Cr√©ation des sous-graphes
fig, axes = plt.subplots(n_rows, n_cols, figsize=(18, 3 * n_rows))
axes = axes.flatten()

# Couleur uniforme et sobre
main_color = sns.color_palette("pastel")[3]

# Boucle sur les colonnes
for i, col in enumerate(columns):
    sns.histplot(previous_application[col].dropna(), kde=True, ax=axes[i], color=main_color)
    axes[i].set_title(f'Distribution: {col}', fontsize=12, weight='bold')
    axes[i].set_xlabel("")  # Facilit√© de lecture
    axes[i].set_ylabel("Fr√©quence")

# Supprimer les axes vides
for j in range(i + 1, len(axes)):
    fig.delaxes(axes[j])

# Ajustement global
plt.suptitle("Distributions des variables num√©riques (previous_application)", fontsize=16, weight='bold', y=1.02)
plt.tight_layout()
plt.show()

# Configuration du style
sns.set_style('whitegrid')

# Liste des colonnes num√©riques uniquement (exclure la cat√©gorielle 'NAME_TYPE_SUITE')
columns = ['AMT_ANNUITY', 'AMT_GOODS_PRICE', 'CNT_PAYMENT',
           'DAYS_FIRST_DRAWING', 'DAYS_FIRST_DUE', 'DAYS_LAST_DUE_1ST_VERSION',
           'DAYS_LAST_DUE', 'DAYS_TERMINATION', 'NFLAG_INSURED_ON_APPROVAL']

# Nombre de colonnes √† afficher
n_cols = 3
n_rows = (len(columns) + n_cols - 1) // n_cols  # Calcul du nombre de lignes

# Cr√©ation des sous-graphes
fig, axes = plt.subplots(n_rows, n_cols, figsize=(15, 4 * n_rows))
axes = axes.flatten()  # Aplatir pour it√©rer facilement

# Tracer chaque distribution
for i, col in enumerate(columns):
    sns.histplot(previous_application[col].dropna(), kde=True, ax=axes[i])
    axes[i].set_title(f'Distribution of {col}')

# Supprimer les axes vides s'il y en a
for j in range(i + 1, len(axes)):
    fig.delaxes(axes[j])

plt.tight_layout()
plt.show()

"""Suggestion

*   AMT_ANNUITY : We can Fill NA with 15955 i.e. Mean for this field
*   AMT_GOODS_PRICE : We can Fill NA with 112320 i.e. Median for this field

*   NAME_TYPE_SUITE : We can Fill NA with Unaccompanied i.e. Mode for this field

*   CNT_PAYMENT : We can Fill NA with 12 i.e. Median for this field
DAYS_FIRST_DRAWING : We can Fill NA with 365243 i.e. Median for this field
*   DAYS_FIRST_DUE : We can Fill NA with -831 i.e. Median for this fielde


*   DAYS_LAST_DUE_1ST_VERSION : We can Fill NA with -361 i.e. Median for this field

*   DAYS_LAST_DUE : We can Fill NA with -537 i.e. Median for this field
*   DAYS_TERMINATION : We can Fill NA with -499 i.e. Median for this field

*   NFLAG_INSURED_ON_APPROVAL : We can Fill NA with 0 i.e. Mode for this field
"""

previous_application['AMT_ANNUITY'].fillna(15955, inplace=True)

# M√©diane
previous_application['AMT_GOODS_PRICE'].fillna(112320, inplace=True)
previous_application['CNT_PAYMENT'].fillna(12, inplace=True)
previous_application['DAYS_FIRST_DRAWING'].fillna(365243, inplace=True)
previous_application['DAYS_FIRST_DUE'].fillna(-831, inplace=True)
previous_application['DAYS_LAST_DUE_1ST_VERSION'].fillna(-361, inplace=True)
previous_application['DAYS_LAST_DUE'].fillna(-537, inplace=True)
previous_application['DAYS_TERMINATION'].fillna(-499, inplace=True)

# Mode
previous_application['NAME_TYPE_SUITE'].fillna('Unaccompanied', inplace=True)
previous_application['NFLAG_INSURED_ON_APPROVAL'].fillna(0, inplace=True)

previous_application[['AMT_ANNUITY', 'AMT_GOODS_PRICE', 'CNT_PAYMENT',
           'DAYS_FIRST_DRAWING', 'DAYS_FIRST_DUE', 'DAYS_LAST_DUE_1ST_VERSION',
           'DAYS_LAST_DUE', 'DAYS_TERMINATION', 'NFLAG_INSURED_ON_APPROVAL']].value_counts()

# Style global am√©lior√©
sns.set_theme(style="whitegrid")

# Colonnes num√©riques √† tracer
columns = ['AMT_ANNUITY', 'AMT_GOODS_PRICE', 'CNT_PAYMENT',
           'DAYS_FIRST_DRAWING', 'DAYS_FIRST_DUE', 'DAYS_LAST_DUE_1ST_VERSION',
           'DAYS_LAST_DUE', 'DAYS_TERMINATION', 'NFLAG_INSURED_ON_APPROVAL']

# Param√®tres de la grille
n_cols = 3
n_rows = (len(columns) + n_cols - 1) // n_cols

# Cr√©ation des sous-graphes
fig, axes = plt.subplots(n_rows, n_cols, figsize=(18, 4 * n_rows))
axes = axes.flatten()

# Palette pastel
box_color = sns.color_palette("pastel")[2]  # douce couleur bleue/verte

# Tracer les boxplots avec style am√©lior√©
for i, col in enumerate(columns):
    sns.boxplot(
        y=previous_application[col],
        ax=axes[i],
        color=box_color,
        linewidth=1.5,
        fliersize=3,   # taille des outliers
        saturation=0.85
    )
    axes[i].set_title(f'Boxplot: {col}', fontsize=12, weight='bold')
    axes[i].set_xlabel("")
    axes[i].set_ylabel("")
    axes[i].grid(True, linestyle='--', linewidth=0.5, alpha=0.6)

# Supprimer les axes inutilis√©s
for j in range(i + 1, len(axes)):
    fig.delaxes(axes[j])

# Ajustements finaux
fig.suptitle("Distribution (Boxplots) des variables num√©riques", fontsize=16, weight='bold', y=1.02)
fig.patch.set_facecolor('#f7f7f7')  # fond gris clair pour harmonie
plt.tight_layout()
plt.show()

"""* Ces boxplots permettent d'identifier la pr√©sence de valeurs aberrantes (outliers) importantes, notamment dans les variables temporelles (comme DAYS_TERMINATION). Ces informations sont cruciales pour le pr√©-traitement."""

previous_application.isnull().sum()

print(previous_application[['AMT_CREDIT', 'PRODUCT_COMBINATION']].isnull().sum())

previous_application[['AMT_CREDIT', 'PRODUCT_COMBINATION']].describe(include='all')

# Style √©l√©gant
sns.set_theme(style="whitegrid", palette="pastel")

# Boxplot : AMT_CREDIT
plt.figure(figsize=(10, 5))
sns.boxplot(
    x=previous_application['AMT_CREDIT'],
    color=sns.color_palette("Set2")[1],
    linewidth=1.5,
    fliersize=3,
    saturation=0.9
)
plt.title("Boxplot de AMT_CREDIT", fontsize=14, weight='bold')
plt.xlabel("Montant du cr√©dit", fontsize=12)
plt.grid(True, linestyle='--', alpha=0.4)
plt.gca().set_facecolor('#fafafa')
plt.tight_layout()
plt.show()
# Countplot : PRODUCT_COMBINATION
plt.figure(figsize=(12, 6))
sns.countplot(
    y=previous_application['PRODUCT_COMBINATION'],
    order=previous_application['PRODUCT_COMBINATION'].value_counts().index,
    palette="viridis"
)
plt.title("Distribution des types de produits (PRODUCT_COMBINATION)", fontsize=14, weight='bold')
plt.xlabel("Nombre d'observations")
plt.ylabel("Type de produit")
plt.grid(axis='x', linestyle='--', alpha=0.4)
plt.gca().set_facecolor('#fafafa')
plt.tight_layout()
plt.show()

"""* Le boxplot montre les outliers dans AMT_CREDIT, indiquant des pr√™ts exceptionnellement √©lev√©s.

* Le countplot identifie les types de produits les plus sollicit√©s.
"""

previous_application['PRODUCT_COMBINATION'].value_counts()

"""

*   We can Fill NA with Cash i.e. Mode for this field

"""

# Classe de couleurs ANSI
class color:
    ORANGE = '\033[33m'  # Teinte orange/jaune
    GREEN = '\033[92m'
    PURPLE = '\033[95m'
    BOLD = '\033[1m'
    END = '\033[0m'

# Colonnes cat√©gorielles (hors 'type')
obj_dtypes = [i for i in previous_application.select_dtypes(include=object).columns if i not in ["type"]]

# Colonnes num√©riques (hors ID et TARGET)
num_dtypes = [i for i in previous_application.select_dtypes(include=np.number).columns if i not in ['SK_ID_CURR', 'TARGET']]

# Affichage
print(color.BOLD + color.PURPLE + 'Colonnes cat√©gorielles :' + color.END + "\n")
for col in obj_dtypes:
    print(color.ORANGE + f"- {col}" + color.END)

print("\n" + color.BOLD + color.PURPLE + 'Colonnes num√©riques :' + color.END + "\n")
for col in num_dtypes:
    print(color.GREEN + f"- {col}" + color.END)

class color:
   PURPLE = '\033[95m'
   CYAN = '\033[96m'
   DARKCYAN = '\033[36m'
   BLUE = '\033[94m'
   GREEN = '\033[92m'
   YELLOW = '\033[93m'
   RED = '\033[91m'
   BOLD = '\033[1m'
   UNDERLINE = '\033[4m'
   END = '\033[0m'

"""Separating numerical and categorical columns from previous_application"""

obj_dtypes = [i for i in previous_application.select_dtypes(include=object).columns if i not in ["type"] ]
num_dtypes = [i for i in previous_application.select_dtypes(include = np.number).columns if i not in ['SK_ID_CURR'] + [ 'TARGET']]

print(color.BOLD + color.PURPLE + 'Categorical Columns' + color.END, "\n")
for x in range(len(obj_dtypes)):
    print(obj_dtypes[x])

print(color.BOLD + color.PURPLE + 'Numerical' + color.END, "\n")
for x in range(len(obj_dtypes)):
    print(obj_dtypes[x])

"""Percentage of Missing values in application_data"""

application_data.columns

# Calcul des pourcentages de valeurs manquantes
missing_data = (application_data.isnull().sum() * 100 / application_data.shape[0]).sort_values(ascending=False)
missing_df = pd.DataFrame({'Column': missing_data.index, 'MissingPercentage': missing_data.values})
missing_df = missing_df[missing_df['MissingPercentage'] > 0]  # On ne garde que les colonnes ayant des valeurs manquantes

# D√©grad√© de couleurs : vert (faible %) ‚Üí rouge (haut %)
norm = plt.Normalize(missing_df['MissingPercentage'].min(), missing_df['MissingPercentage'].max())
colors = plt.cm.RdYlGn_r(norm(missing_df['MissingPercentage']))  # "_r" pour inverser (rouge = √©lev√©)

# Plot
plt.figure(figsize=(12, max(6, len(missing_df) * 0.3)))  # Ajustement dynamique de la taille
bars = plt.barh(missing_df['Column'], missing_df['MissingPercentage'], color=colors, edgecolor='black')

# Ajout des √©tiquettes sur les barres
for bar in bars:
    width = bar.get_width()
    plt.text(width + 1, bar.get_y() + bar.get_height() / 2, f'{width:.1f}%', va='center', fontsize=9)

# Esth√©tique
plt.title('Pourcentage de valeurs manquantes par colonne', fontsize=14, weight='bold')
plt.xlabel('Pourcentage (%)')
plt.ylabel('Colonnes')
plt.grid(axis='x', linestyle='--', alpha=0.5)
plt.tight_layout()
plt.gca().invert_yaxis()  # Colonnes les plus manquantes en haut
plt.show()

"""* Certaines colonnes ont un taux de valeurs manquantes √©lev√© (>40%), √† traiter avant mod√©lisation.

Removing columns with missing values more than 40%
As per Industrial Standard, max Threshold limit can be between 40% to 50 % depending upon the data acquired in specific sector.
"""

application_data=application_data.drop([ 'EXT_SOURCE_1', 'EXT_SOURCE_2', 'EXT_SOURCE_3',
       'APARTMENTS_AVG', 'BASEMENTAREA_AVG', 'YEARS_BEGINEXPLUATATION_AVG',
       'YEARS_BUILD_AVG', 'COMMONAREA_AVG', 'ELEVATORS_AVG', 'ENTRANCES_AVG',
       'FLOORSMAX_AVG', 'FLOORSMIN_AVG', 'LANDAREA_AVG',
       'LIVINGAPARTMENTS_AVG', 'LIVINGAREA_AVG', 'NONLIVINGAPARTMENTS_AVG',
       'NONLIVINGAREA_AVG', 'APARTMENTS_MODE', 'BASEMENTAREA_MODE',
       'YEARS_BEGINEXPLUATATION_MODE', 'YEARS_BUILD_MODE', 'COMMONAREA_MODE',
       'ELEVATORS_MODE', 'ENTRANCES_MODE', 'FLOORSMAX_MODE', 'FLOORSMIN_MODE',
       'LANDAREA_MODE', 'LIVINGAPARTMENTS_MODE', 'LIVINGAREA_MODE',
       'NONLIVINGAPARTMENTS_MODE', 'NONLIVINGAREA_MODE', 'APARTMENTS_MEDI',
       'BASEMENTAREA_MEDI', 'YEARS_BEGINEXPLUATATION_MEDI', 'YEARS_BUILD_MEDI',
       'COMMONAREA_MEDI', 'ELEVATORS_MEDI', 'ENTRANCES_MEDI', 'FLOORSMAX_MEDI',
       'FLOORSMIN_MEDI', 'LANDAREA_MEDI', 'LIVINGAPARTMENTS_MEDI',
       'LIVINGAREA_MEDI', 'NONLIVINGAPARTMENTS_MEDI', 'NONLIVINGAREA_MEDI',
       'FONDKAPREMONT_MODE', 'HOUSETYPE_MODE', 'TOTALAREA_MODE',
       'WALLSMATERIAL_MODE', 'EMERGENCYSTATE_MODE',"OWN_CAR_AGE"],axis=1)

# Pr√©paration des donn√©es
miss_application_data = pd.DataFrame((application_data.isnull().sum() * 100 / application_data.shape[0])).reset_index()
miss_application_data.columns = ["Column", "MissingPercentage"]
miss_application_data = miss_application_data[miss_application_data["MissingPercentage"] > 0]  # Ne garder que les colonnes avec valeurs manquantes
miss_application_data = miss_application_data.sort_values(by="MissingPercentage", ascending=False)

# D√©grad√© de couleurs (du vert au rouge)
norm = plt.Normalize(miss_application_data["MissingPercentage"].min(), miss_application_data["MissingPercentage"].max())
colors = plt.cm.RdYlGn_r(norm(miss_application_data["MissingPercentage"]))  # rouge = beaucoup de valeurs manquantes

# Cr√©ation du barplot
plt.figure(figsize=(18, 6))
bars = plt.bar(miss_application_data["Column"], miss_application_data["MissingPercentage"], color=colors, edgecolor='black')

# Ajout des pourcentages au-dessus des barres
for bar in bars:
    height = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2, height + 0.5, f'{height:.1f}%', ha='center', va='bottom', fontsize=8)

# Esth√©tique
plt.xticks(rotation=90, fontsize=8)
plt.yticks(fontsize=10)
plt.title("Pourcentage de valeurs manquantes par colonne (application_data)", fontsize=14, fontweight='bold')
plt.xlabel("Colonnes", fontsize=12)
plt.ylabel("Pourcentage (%)", fontsize=12)
plt.grid(axis='y', linestyle='--', alpha=0.4)
plt.tight_layout()
plt.show()

application_data[['OCCUPATION_TYPE','AMT_REQ_CREDIT_BUREAU_DAY', 'AMT_REQ_CREDIT_BUREAU_HOUR', 'AMT_REQ_CREDIT_BUREAU_MON', 'AMT_REQ_CREDIT_BUREAU_QRT', 'AMT_REQ_CREDIT_BUREAU_WEEK', 'AMT_REQ_CREDIT_BUREAU_YEAR', 'DEF_30_CNT_SOCIAL_CIRCLE', 'DEF_30_CNT_SOCIAL_CIRCLE', 'OBS_60_CNT_SOCIAL_CIRCLE', 'DEF_60_CNT_SOCIAL_CIRCLE']].isnull().sum()

application_data[['OCCUPATION_TYPE','AMT_REQ_CREDIT_BUREAU_DAY', 'AMT_REQ_CREDIT_BUREAU_HOUR', 'AMT_REQ_CREDIT_BUREAU_MON', 'AMT_REQ_CREDIT_BUREAU_QRT', 'AMT_REQ_CREDIT_BUREAU_WEEK', 'AMT_REQ_CREDIT_BUREAU_YEAR', 'DEF_30_CNT_SOCIAL_CIRCLE', 'DEF_30_CNT_SOCIAL_CIRCLE', 'OBS_60_CNT_SOCIAL_CIRCLE', 'DEF_60_CNT_SOCIAL_CIRCLE']].describe()

"""

*   AMT_REQ_CREDIT_BUREAU_DAY : We can Fill NA with 0 i.e. Median for this field

*   AMT_REQ_CREDIT_BUREAU_HOUR : We can Fill NA with 0 i.e. Median for this field

*   AMT_REQ_CREDIT_BUREAU_MON : We can Fill NA with 0 i.e. Median for this field
*   AMT_REQ_CREDIT_BUREAU_QRT : We can Fill NA with 0 i.e. Median for this field


*   AMT_REQ_CREDIT_BUREAU_WEEK : We can Fill NA with 0 i.e. Median for this field


*   AMT_REQ_CREDIT_BUREAU_YEAR : We can Fill NA with 0 i.e. Median for this field

*   DEF_30_CNT_SOCIAL_CIRCLE : We can Fill NA with 0 i.e. Median for this field
*   DEF_30_CNT_SOCIAL_CIRCLE : We can Fill NA with 0 i.e. Median for this field

*   DEF_60_CNT_SOCIAL_CIRCLE : We can Fill NA with 0 i.e. Median for this field
"""

# Liste des colonnes √† remplir avec 0
filna = [
    'AMT_REQ_CREDIT_BUREAU_DAY',
    'AMT_REQ_CREDIT_BUREAU_HOUR',
    'AMT_REQ_CREDIT_BUREAU_MON',
    'AMT_REQ_CREDIT_BUREAU_QRT',
    'AMT_REQ_CREDIT_BUREAU_WEEK',
    'AMT_REQ_CREDIT_BUREAU_YEAR',
    'DEF_30_CNT_SOCIAL_CIRCLE',
    'DEF_60_CNT_SOCIAL_CIRCLE'
]

# Remplir les NaN avec 0
application_data[filna] = application_data[filna].fillna(0)

application_data.isnull().sum()

application_data[['AMT_ANNUITY', 'AMT_GOODS_PRICE', 'NAME_TYPE_SUITE', 'CNT_FAM_MEMBERS',
                            'DAYS_LAST_PHONE_CHANGE']].isnull().sum()

# Configuration du style
sns.set_style('whitegrid')

# Liste des colonnes num√©riques uniquement (exclure la cat√©gorielle 'NAME_TYPE_SUITE')
columns = ['AMT_ANNUITY', 'AMT_GOODS_PRICE', 'NAME_TYPE_SUITE', 'CNT_FAM_MEMBERS',
                            'DAYS_LAST_PHONE_CHANGE']

# Nombre de colonnes √† afficher
n_cols = 3
n_rows = (len(columns) + n_cols - 1) // n_cols  # Calcul du nombre de lignes

# Cr√©ation des sous-graphes
fig, axes = plt.subplots(n_rows, n_cols, figsize=(15, 4 * n_rows))
axes = axes.flatten()  # Aplatir pour it√©rer facilement

# Tracer chaque distribution
for i, col in enumerate(columns):
    sns.histplot(application_data[col].dropna(), kde=True, ax=axes[i])
    axes[i].set_title(f'Distribution of {col}')

# Supprimer les axes vides s'il y en a
for j in range(i + 1, len(axes)):
    fig.delaxes(axes[j])

plt.tight_layout()
plt.show()

"""* Donne une id√©e des distributions : AMT_GOODS_PRICE peut √™tre bimodale.

* Certains champs comme CNT_FAM_MEMBERS semblent discrets.
"""

application_data[['AMT_ANNUITY', 'AMT_GOODS_PRICE', 'NAME_TYPE_SUITE', 'CNT_FAM_MEMBERS',
                            'DAYS_LAST_PHONE_CHANGE']].describe()

"""

*   AMT_ANNUITY : We can Fill NA with 0 i.e. Mean for this field as it's right skewed graph

*   AMT_GOODS_PRICE : We can Fill NA with 0 i.e. Mean for this field as it's right skewed graph
*   NAME_TYPE_SUITE : We can Fill NA with "Unaccompanied" i.e. Mode for this field


*   CNT_FAM_MEMBERS : We can Fill NA with 2 i.e. Median for this field, Mean is not be used as this field needs to be Whole number"""

# Remplissage par la moyenne (0) pour donn√©es asym√©triques √† droite
application_data['AMT_ANNUITY'].fillna(0, inplace=True)
application_data['AMT_GOODS_PRICE'].fillna(0, inplace=True)

# Remplissage par le mode pour variable cat√©gorique
application_data['NAME_TYPE_SUITE'].fillna('Unaccompanied', inplace=True)

# Remplissage par la m√©diane (entier) pour variable enti√®re
application_data['CNT_FAM_MEMBERS'].fillna(2, inplace=True)



import statistics
statistics.mode(application_data['DAYS_LAST_PHONE_CHANGE'])
#We can Fill NA with 0 i.e. Mode for this field

"""*   DAYS_LAST_PHONE_CHANGE correspond au nombre de jours depuis le dernier changement de t√©l√©phone (n√©gatif = dans le pass√©).
*   Un mode de 0 peut indiquer "chang√© aujourd'hui" ou une valeur par d√©faut dans le dataset.
"""

# Trouver le mode avec pandas (prend le premier si plusieurs)
mode_value = application_data['DAYS_LAST_PHONE_CHANGE'].mode()[0]

# Remplir les NaN avec le mode (ou directement 0 si tu choisis arbitrairement 0)
application_data['DAYS_LAST_PHONE_CHANGE'].fillna(0, inplace=True)

"""**Print the information about the attributes of application_data**"""

print(type(application_data.info()))

"""**Converting negative values to absolute values**"""

application_data['DAYS_BIRTH'] = abs(application_data['DAYS_BIRTH'])
application_data['DAYS_ID_PUBLISH'] = abs(application_data['DAYS_ID_PUBLISH'])
application_data['DAYS_ID_PUBLISH'] = abs(application_data['DAYS_ID_PUBLISH'])
application_data['DAYS_LAST_PHONE_CHANGE'] = abs(application_data['DAYS_LAST_PHONE_CHANGE'])

display("application_data")
display(application_data.head())

"""**Separating numerical and categorical in application_data**"""

obj_dtypes = [i for i in application_data.select_dtypes(include=object).columns if i not in ["type"] ]
num_dtypes = [i for i in application_data.select_dtypes(include = np.number).columns if i not in ['SK_ID_CURR'] + [ 'TARGET']]

# D√©finir les couleurs
class color:
    PURPLE = '\033[95m'
    BOLD = '\033[1m'
    END = '\033[0m'

# Imprimer les colonnes cat√©goriques
print(color.BOLD + color.PURPLE + 'Categorical Columns' + color.END, "\n")
for col in obj_dtypes:
    print(col)

# Imprimer les colonnes num√©riques
print("\n" + color.BOLD + color.PURPLE + 'Numerical Columns' + color.END, "\n")
for col in num_dtypes:
    print(col)

"""**Imbalance percentage**"""

fig = plt.figure(figsize=(13,6))
plt.subplot(121)
application_data["CODE_GENDER"].value_counts().plot.pie(autopct = "%1.0f%%",colors = ["red","yellow"],startangle = 60,
                                                                        wedgeprops={"linewidth":2,"edgecolor":"k"},explode=[.05,0,0],shadow =True)
plt.title("Distribution of gender")
plt.show()

"""**Distribution of Target variable**

TARGET :Target variable (1 - client with payment difficulties: he/she had late payment more than X days on at least one of the first Y installments of the loan in sample, 0 - all other cases)
"""

# Donn√©es
target_counts = application_data["TARGET"].value_counts()
labels = ["Repayer", "Defaulter"]
colors = sns.color_palette("Set2", 2)  # Palette douce et lisible

# Figure
plt.figure(figsize=(14, 6))

# Camembert (Pie Chart)
plt.subplot(1, 2, 1)
plt.pie(
    target_counts,
    labels=labels,
    autopct="%1.0f%%",
    startangle=60,
    colors=colors,
    explode=[0.1, 0],
    shadow=True,
    wedgeprops={"linewidth": 1.5, "edgecolor": "black"},
    textprops={'fontsize': 11}
)
plt.title("Distribution of Target Variable", fontsize=14, fontweight="bold")

# Barplot horizontal
plt.subplot(1, 2, 2)
ax = target_counts.plot(kind="barh", color=colors, edgecolor="black")

for i, val in enumerate(target_counts.values):
    ax.text(val + max(target_counts.values)*0.01, i, str(val), va='center', fontsize=13, weight='bold', color='black')

# Esth√©tique
ax.set_yticklabels(labels, fontsize=11)
ax.set_xlabel("Count", fontsize=12)
plt.title("Count of Target Variable", fontsize=14, fontweight="bold")
plt.grid(axis='x', linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

"""8% out of total client population have difficulties in repaying loans.

**Concatenating application_data and previous_application**
"""

application_data_x = application_data[[x for x in application_data.columns if x not in ["TARGET"]]]
previous_application_x = previous_application[[x for x in previous_application.columns if x not in ["TARGET"]]]
application_data_x["type"] = "application_data"
previous_application_x["type"] = "previous_application"
data = pd.concat([application_data_x,previous_application_x],axis=0)

"""**Distribution in Contract types in application_data**

NAME_CONTRACT_TYPE : Identification if loan is cash , consumer or revolving
"""

# R√©cup√©rer les valeurs
app_contract = data[data["type"] == "application_data"]["NAME_CONTRACT_TYPE"].value_counts()
prev_contract = data[data["type"] == "previous_application"]["NAME_CONTRACT_TYPE"].value_counts()

# D√©finir des couleurs dynamiques (autant que n√©cessaire)
colors_app = sns.color_palette("Set2", len(app_contract))
colors_prev = sns.color_palette("Set3", len(prev_contract))

# Cr√©ation de la figure
fig, axes = plt.subplots(1, 2, figsize=(14, 7))

# Pie chart - application_data
axes[0].pie(
    app_contract,
    labels=app_contract.index,
    autopct='%1.0f%%',
    startangle=60,
    colors=colors_app,
    wedgeprops={"linewidth": 2, "edgecolor": "white"},
    shadow=True
)
# Donut
centre_circle = plt.Circle((0, 0), 0.70, fc='white')
axes[0].add_artist(centre_circle)
axes[0].set_title("Contract Types in Application Data", fontsize=13, fontweight='bold')

# Pie chart - previous_application
axes[1].pie(
    prev_contract,
    labels=prev_contract.index,
    autopct='%1.2f%%',
    startangle=60,
    colors=colors_prev,
    wedgeprops={"linewidth": 2, "edgecolor": "white"},
    shadow=True
)
centre_circle2 = plt.Circle((0, 0), 0.70, fc='white')
axes[1].add_artist(centre_circle2)
axes[1].set_title("Contract Types in Previous Applications", fontsize=13, fontweight='bold')

# Ajustements
plt.tight_layout()
plt.show()

"""The percentage of revolving loans and cash loans are 10% & 90%.

**Gender Distribution in application_data**
"""

fig = plt.figure(figsize=(13,6))
plt.subplot(121)
data[data["type"] == "application_data"]["CODE_GENDER"].value_counts().plot.pie(autopct = "%1.0f%%",colors = ["red","yellow"],startangle = 60,
                                                                        wedgeprops={"linewidth":2,"edgecolor":"k"},explode=[.05,0,0],shadow =True)
plt.title("distribution of gender in application_data")
plt.show()

"""Female : 66%

Male : 34%

**Distribution of Contract type by gender**
"""

plt.figure(figsize=(10, 6))

# Tracer le countplot
ax = sns.countplot(
    data=data[data["type"] == "application_data"],
    x="NAME_CONTRACT_TYPE",
    hue="CODE_GENDER",
    palette=sns.color_palette("Set1")  # palette plus lisible
)

# Esth√©tique
ax.set_facecolor("whitesmoke")
ax.set_title("Distribution of Contract Type by Gender ‚Äî Application Data", fontsize=14, fontweight="bold")
ax.set_xlabel("Contract Type", fontsize=12)
ax.set_ylabel("Count", fontsize=12)
plt.xticks(rotation=15)
plt.legend(title="Gender", title_fontsize=11)

# Afficher les valeurs au-dessus des barres
for container in ax.containers:
    ax.bar_label(container, fmt='%d', label_type='edge', fontsize=10, padding=2)

plt.tight_layout()
plt.show()

"""Cash loans is always prefered over Revolving loans by both genders

**Distribution of client owning a car and by gender**

FLAG_OWN_CAR Flag if the client owns a car
"""

fig = plt.figure(figsize=(13,6))

plt.subplot(121)
data["FLAG_OWN_CAR"].value_counts().plot.pie(autopct = "%1.0f%%",colors = ["gold","orangered"],startangle = 60,
                                                                        wedgeprops={"linewidth":2,"edgecolor":"k"},explode=[.05,0],shadow =True)
plt.title("distribution of client owning a car")

plt.subplot(122)
data[data["FLAG_OWN_CAR"] == "Y"]["CODE_GENDER"].value_counts().plot.pie(autopct = "%1.0f%%",colors = ["b","orangered"],startangle = 90,
                                                                        wedgeprops={"linewidth":2,"edgecolor":"k"},explode=[.05,0,0],shadow =True)
plt.title("distribution of client owning a car by gender")

plt.show()

"""* SUBPLOT 1 : Distribution of client owning a car. 34% of clients own a car .

* SUBPLOT 2 : Distribution of client owning a car by gender. Out of total clients who own car 57% are male and 43% are female.

**Distribution of client owning a house or flat and by gender**

FLAG_OWN_REALTY - Flag if client owns a house or flat
"""

plt.figure(figsize=(13,6))
plt.subplot(121)
data["FLAG_OWN_REALTY"].value_counts().plot.pie(autopct = "%1.0f%%",colors = ["skyblue","gold"],startangle = 90,
                                              wedgeprops={"linewidth":2,"edgecolor":"k"},explode=[0.05,0],shadow =True)
plt.title("Distribution of client owns a house or flat")

plt.subplot(122)
data[data["FLAG_OWN_REALTY"] == "Y"]["CODE_GENDER"].value_counts().plot.pie(autopct = "%1.0f%%",colors = ["orangered","b"],startangle = 90,
                                                                        wedgeprops={"linewidth":2,"edgecolor":"k"},explode=[.05,0,0],shadow =True)
plt.title("Distribution of client owning a house or flat by gender")
plt.show()

"""*   SUBPLOT 1 : Distribution of client owning a house or flat . 69% of clients own a flat or house .

*   SUBPLOT 2 : Distribution of client owning a house or flat by gender . Out of total clients who own house 67% are female and 33% are male

**Distribution of Number of children and family members of client by repayment status**.

*  CNT_CHILDREN - Number of children the client has.


*   CNT_FAM_MEMBERS - How many family members does client have
"""

fig = plt.figure(figsize=(12, 10))

# First plot
plt.subplot(211)
sns.countplot(
    x="CNT_CHILDREN",
    hue="TARGET",
    data=application_data,
    palette="Set1"
)
plt.legend(loc="upper center")
plt.title("Distribution of Number of Children Client Has by Repayment Status")

# Second plot
plt.subplot(212)
sns.countplot(
    x="CNT_FAM_MEMBERS",
    hue="TARGET",
    data=application_data,
    palette="Set1"
)
plt.legend(loc="upper center")
plt.title("Distribution of Number of Family Members Client Has by Repayment Status")

# Set overall figure background
fig.set_facecolor("lightblue")

plt.tight_layout()
plt.show()

"""**Distribution of contract type ,gender ,own car ,own house with respect to Repayment status(Target variable)**"""

default = application_data[application_data["TARGET"]==1][[ 'NAME_CONTRACT_TYPE', 'CODE_GENDER','FLAG_OWN_CAR', 'FLAG_OWN_REALTY']]
non_default = application_data[application_data["TARGET"]==0][[ 'NAME_CONTRACT_TYPE', 'CODE_GENDER','FLAG_OWN_CAR', 'FLAG_OWN_REALTY']]

d_cols = ['NAME_CONTRACT_TYPE', 'CODE_GENDER','FLAG_OWN_CAR', 'FLAG_OWN_REALTY']
d_length = len(d_cols)

fig = plt.figure(figsize=(16,4))
for i,j in itertools.zip_longest(d_cols,range(d_length)):
    plt.subplot(1,4,j+1)
    default[i].value_counts().plot.pie(autopct = "%1.0f%%",colors = sns.color_palette("prism"),startangle = 90,
                                        wedgeprops={"linewidth":1,"edgecolor":"white"},shadow =True)
    circ = plt.Circle((0,0),.7,color="white")
    plt.gca().add_artist(circ)
    plt.ylabel("")
    plt.title(i+"-Defaulter")


fig = plt.figure(figsize=(16,4))
for i,j in itertools.zip_longest(d_cols,range(d_length)):
    plt.subplot(1,4,j+1)
    non_default[i].value_counts().plot.pie(autopct = "%1.0f%%",colors = sns.color_palette("prism",3),startangle = 90,
                                           wedgeprops={"linewidth":1,"edgecolor":"white"},shadow =True)
    circ = plt.Circle((0,0),.7,color="white")
    plt.gca().add_artist(circ)
    plt.ylabel("")
    plt.title(i+"-Repayer")

"""
*   Percentage of males is 10% more in defaults than non defaulters.

*   Percentage of Cash Loans is 4% more in defaults than Revolving Loans.

**Distribution of amount data**

*   AMT_INCOME_TOTAL - Income of the client
*   AMT_CREDIT - Credit amount of the loan

*   AMT_ANNUITY - Loan annuity
*   AMT_GOODS_PRICE - For consumer loans it is the price of the goods for which the loan is given










"""

cols = [ 'AMT_INCOME_TOTAL', 'AMT_CREDIT','AMT_ANNUITY', 'AMT_GOODS_PRICE']
length = len(cols)
cs = ["r","b","g","k"]

ax = plt.figure(figsize=(18,18))
ax.set_facecolor("lightgrey")
for i,j,k in itertools.zip_longest(cols,range(length),cs):
    plt.subplot(2,2,j+1)
    sns.distplot(data[data[i].notnull()][i],color=k)
    plt.axvline(data[i].mean(),label = "mean",linestyle="dashed",color="k")
    plt.legend(loc="best")
    plt.title(i)
    plt.subplots_adjust(hspace = .2)

"""**Comparing summary statistics between defaulters and non - defaulters for loan amounts.**"""

application_data.head(1)

cols = [ 'AMT_INCOME_TOTAL', 'AMT_CREDIT','AMT_ANNUITY', 'AMT_GOODS_PRICE']
df = application_data.groupby("TARGET")[cols].describe().transpose().reset_index()

df = application_data.groupby("TARGET")[cols].describe().transpose().reset_index()
df = df[df["level_1"].isin([ 'mean', 'std', 'min', 'max'])]
df_x = df[["level_0","level_1",0]]
df_y = df[["level_0","level_1",1]]
df_x = df_x.rename(columns={'level_0':"amount_type", 'level_1':"statistic", 0:"amount"})
df_x["type"] = "REPAYER"
df_y = df_y.rename(columns={'level_0':"amount_type", 'level_1':"statistic", 1:"amount"})
df_y["type"] = "DEFAULTER"
df_new = pd.concat([df_x,df_y],axis = 0)

stat = df_new["statistic"].unique().tolist()
length = len(stat)

plt.figure(figsize=(13,15))

for i,j in itertools.zip_longest(stat,range(length)):
    plt.subplot(2,2,j+1)
    fig = sns.barplot(x= df_new[df_new["statistic"] == i]["amount_type"], y=df_new[df_new["statistic"] == i]["amount"],
                hue=df_new[df_new["statistic"] == i]["type"],palette=["g","r"])
    plt.title(i + "--Defaulters vs Non defaulters")
    plt.subplots_adjust(hspace = .4)
    fig.set_facecolor("lightgrey")

plt.figure(figsize=(13, 15))

for i, j in zip(stat, range(length)):
    plt.subplot(2, 2, j + 1)

    sns.barplot(
        x="amount_type",
        y="amount",
        hue="type",
        data=df_new[df_new["statistic"] == i],
        palette=["#2ecc71", "#e74c3c"]
    )

    plt.title(f"{i.capitalize()} ‚Äî Defaulters vs Non-defaulters", fontsize=13, fontweight="bold")
    plt.gca().set_facecolor("whitesmoke")
    plt.xticks(rotation=15)
    plt.xlabel("Amount Type")
    plt.ylabel("Amount")
    plt.legend(title="Client Type", title_fontsize=10)

plt.subplots_adjust(hspace=0.4)
plt.tight_layout()
plt.show()

plt.figure(figsize=(13, 15))

for i, j in itertools.zip_longest(stat, range(length)):
    plt.subplot(2, 2, j + 1)

    sns.barplot(
        x="amount_type",
        y="amount",
        hue="type",
        data=df_new[df_new["statistic"] == i],
        palette=["g", "r"]
    )

    plt.title(f"{i} -- Defaulters vs Non defaulters")
    plt.gca().set_facecolor("lightgrey")

plt.subplots_adjust(hspace=0.4)
plt.show()

"""**Income of client**
1 . Average income of clients who default and who do not are almost same.

2 . Standard deviation in income of client who default is very high compared to who do not default.

3 . Clients who default also has maximum income earnings

**Credit amount of the loan ,Loan annuity,Amount goods price**

1 . Statistics between credit amounts,Loan annuity and Amount goods price given to cilents who default and who dont are almost similar.

**Average Income,credit,annuity & goods_price by gender**
"""

cols = [ 'AMT_INCOME_TOTAL', 'AMT_CREDIT','AMT_ANNUITY', 'AMT_GOODS_PRICE']

df1 = data.groupby("CODE_GENDER")[cols].mean().transpose().reset_index()

df_f   = df1[["index","F"]]
df_f   = df_f.rename(columns={'index':"amt_type", 'F':"amount"})
df_f["gender"] = "FEMALE"
df_m   = df1[["index","M"]]
df_m   = df_m.rename(columns={'index':"amt_type", 'M':"amount"})
df_m["gender"] = "MALE"
df_xna = df1[["index","XNA"]]
df_xna = df_xna.rename(columns={'index':"amt_type", 'XNA':"amount"})
df_xna["gender"] = "XNA"

df_gen = pd.concat([df_m,df_f,df_xna],axis=0)

plt.figure(figsize=(12,5))
ax = sns.barplot(x="amt_type", y="amount",data=df_gen,hue="gender",palette="Set1")
plt.title("Average Income,credit,annuity & goods_price by gender")
plt.show()

"""**Scatter plot between credit amount and annuity amount**"""

fig = plt.figure(figsize=(10,8))
plt.scatter(application_data[application_data["TARGET"]==0]['AMT_ANNUITY'],application_data[application_data["TARGET"]==0]['AMT_CREDIT'],s=35,
            color="b",alpha=.5,label="REPAYER",linewidth=.5,edgecolor="k")
plt.scatter(application_data[application_data["TARGET"]==1]['AMT_ANNUITY'],application_data[application_data["TARGET"]==1]['AMT_CREDIT'],s=35,
            color="r",alpha=.2,label="DEFAULTER",linewidth=.5,edgecolor="k")
plt.legend(loc="best",prop={"size":15})
plt.xlabel("AMT_ANNUITY")
plt.ylabel("AMT_CREDIT")
plt.title("Scatter plot between credit amount and annuity amount")
plt.show()

"""**Pair Plot between amount variables**


*   AMT_INCOME_TOTAL - Income of the client
*   AMT_CREDIT - Credit amount of the loan

*   AMT_ANNUITY - Loan annuity
*   AMT_GOODS_PRICE - For consumer loans it is the price of the goods for which the loan is given
"""

amt = application_data[[ 'AMT_INCOME_TOTAL','AMT_CREDIT',
                         'AMT_ANNUITY', 'AMT_GOODS_PRICE',"TARGET"]]
amt = amt[(amt["AMT_GOODS_PRICE"].notnull()) & (amt["AMT_ANNUITY"].notnull())]
sns.pairplot(amt,hue="TARGET",palette=["b","r"])
plt.show()

"""**Distribution of Suite type**

*   NAME_TYPE_SUITE - Who was accompanying client when he was applying for the
"""

plt.figure(figsize=(18,12))
plt.subplot(121)
sns.countplot(y=application_data["NAME_TYPE_SUITE"],
              palette="Set2",
              order=application_data["NAME_TYPE_SUITE"].value_counts().index[:5])
plt.title("Distribution of Suite type")

plt.subplot(122)
sns.countplot(y=application_data["NAME_TYPE_SUITE"],
              hue=application_data["CODE_GENDER"],palette="Set2",
              order=application_data["NAME_TYPE_SUITE"].value_counts().index[:5])
plt.ylabel("")
plt.title("Distribution of Suite type by gender")
plt.subplots_adjust(wspace = .4)

"""**Distribution of client income type**

*   NAME_INCOME_TYPE Clients income type (businessman, working, maternity leave,‚Ä¶)



"""

plt.figure(figsize=(18,12))
plt.subplot(121)
sns.countplot(y=application_data["NAME_INCOME_TYPE"],
              palette="Set2",
              order=application_data["NAME_INCOME_TYPE"].value_counts().index[:4])
plt.title("Distribution of client income type")

plt.subplot(122)
sns.countplot(y=application_data["NAME_INCOME_TYPE"],
              hue=application_data["CODE_GENDER"],
              palette="Set2",
              order=application_data["NAME_INCOME_TYPE"].value_counts().index[:4])
plt.ylabel("")
plt.title("Distribution of client income  type by gender")
plt.subplots_adjust(wspace = .4)

"""Distribution of Education type by loan repayment status
NAME_EDUCATION_TYPE Level of highest education the client achieved
"""

plt.figure(figsize=(25,25))
plt.subplot(121)
application_data[application_data["TARGET"]==0]["NAME_EDUCATION_TYPE"].value_counts().plot.pie(fontsize=12,autopct = "%1.0f%%",
                                                                                                 colors = sns.color_palette("Set1"),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True)
circ = plt.Circle((0,0),.7,color="white")
plt.gca().add_artist(circ)
plt.title("Distribution of Education type for Repayers",color="b")

plt.subplot(122)
application_data[application_data["TARGET"]==1]["NAME_EDUCATION_TYPE"].value_counts().plot.pie(fontsize=12,autopct = "%1.0f%%",
                                                                                                 colors = sns.color_palette("Set1"),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True)
circ = plt.Circle((0,0),.7,color="white")
plt.gca().add_artist(circ)
plt.title("Distribution of Education type for Defaulters",color="b")
plt.ylabel("")
plt.show()

"""Clients who default have proportionally 9% less higher education compared to clients who do not default.

**Average Earnings by different professions and education types**
"""

edu = data.groupby(['NAME_EDUCATION_TYPE','NAME_INCOME_TYPE'])['AMT_INCOME_TOTAL'].mean().reset_index().sort_values(by='AMT_INCOME_TOTAL',ascending=False)
fig = plt.figure(figsize=(13,7))
ax = sns.barplot(x='NAME_INCOME_TYPE', y='AMT_INCOME_TOTAL',data=edu,hue='NAME_EDUCATION_TYPE',palette="seismic")
ax.set_facecolor("k")
plt.title(" Average Earnings by different professions and education types")
plt.show()

"""**Distribution of Education type by loan repayment status**

*   NAME_FAMILY_STATUS - Family status of the client
"""

plt.figure(figsize=(16,8))
plt.subplot(121)
application_data[application_data["TARGET"]==0]["NAME_FAMILY_STATUS"].value_counts().plot.pie(autopct = "%1.0f%%",
                                                             startangle=120,colors = sns.color_palette("Set2",7),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True,explode=[0,.07,0,0,0,0])

plt.title("Distribution of Family status for Repayers",color="b")

plt.subplot(122)
application_data[application_data["TARGET"]==1]["NAME_FAMILY_STATUS"].value_counts().plot.pie(autopct = "%1.0f%%",
                                                    startangle=120,colors = sns.color_palette("Set2",7),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True,explode=[0,.07,0,0,0])


plt.title("Distribution of Family status for Defaulters",color="b")
plt.ylabel("")
plt.show()

"""


*   Percentage of single people are more in defaulters than non defaulters.


**Distribution of Housing type by loan repayment status**

*   NAME_HOUSING_TYPE - What is the housing situation of the client (renting, living with parents, ...)


"""

plt.figure(figsize=(20,20))
plt.subplot(121)
application_data[application_data["TARGET"]==0]["NAME_HOUSING_TYPE"].value_counts().plot.pie(autopct = "%1.0f%%",fontsize=10,
                                                             colors = sns.color_palette("Spectral"),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True)

plt.title("Distribution of housing type  for Repayer",color="b")

plt.subplot(122)
application_data[application_data["TARGET"]==1]["NAME_HOUSING_TYPE"].value_counts().plot.pie(autopct = "%1.0f%%",fontsize=10,
                                                    colors = sns.color_palette("Spectral"),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True)


plt.title("Distribution of housing type for Defaulters",color="b")
plt.ylabel("")
plt.show()

"""**Distribution normalized population of region where client lives by loan repayment status**

*   REGION_POPULATION_RELATIVE - Normalized population of region where client lives (higher number means the client lives in more populated region).



"""

fig = plt.figure(figsize=(13,8))

plt.subplot(121)
sns.violinplot(y=application_data[application_data["TARGET"]==0]["REGION_POPULATION_RELATIVE"]
               ,x=application_data[application_data["TARGET"]==0]["NAME_CONTRACT_TYPE"],
               palette="Set1")
plt.title("Distribution of region population for Non Default loans",color="b")
plt.subplot(122)
sns.violinplot(y = application_data[application_data["TARGET"]==1]["REGION_POPULATION_RELATIVE"]
               ,x=application_data[application_data["TARGET"]==1]["NAME_CONTRACT_TYPE"]
               ,palette="Set1")
plt.title("Distribution of region population  for  Default loans",color="b")

plt.subplots_adjust(wspace = .2)
fig.set_facecolor("lightgrey")

"""


.

*   In High population density regions people are less likely to default on loans.
**Client's age**

*   DAYS_BIRTH - Client's age in days at the time of application



"""

fig = plt.figure(figsize=(13,15))

plt.subplot(221)
sns.histplot(application_data[application_data["TARGET"]==0]["DAYS_BIRTH"], color="b", kde=True)
plt.title("Age Distribution of repayers")

plt.subplot(222)
sns.histplot(application_data[application_data["TARGET"]==1]["DAYS_BIRTH"], color="r", kde=True)
plt.title("Age Distribution of defaulters")

plt.subplot(223)
sns.boxplot(x=application_data["TARGET"], y=application_data["DAYS_BIRTH"], hue=application_data["CODE_GENDER"], palette=["b","grey","m"])
plt.axhline(application_data["DAYS_BIRTH"].mean(), linestyle="dashed", color="k", label="average age of client")
plt.legend(loc="lower right")
plt.title("Client age vs Loan repayment status (hue=gender)")

plt.subplot(224)
sns.boxplot(x=application_data["TARGET"], y=application_data["DAYS_BIRTH"], hue=application_data["NAME_CONTRACT_TYPE"], palette=["r","g"])
plt.axhline(application_data["DAYS_BIRTH"].mean(), linestyle="dashed", color="k", label="average age of client")
plt.legend(loc="lower right")
plt.title("Client age vs Loan repayment status (hue=contract type)")

plt.subplots_adjust(wspace=0.2, hspace=0.3)
fig.set_facecolor("lightgrey")
plt.show()

"""*   Average clients age is comparatively less in non repayers than repayers in every aspect.

*   Younger people tend to default more than elder people.

**Distribution of days employed for target variable.**

*   DAYS_EMPLOYED - How many days before the application for target variable the person started current employment
"""

fig = plt.figure(figsize=(13,5))

plt.subplot(121)
sns.distplot(application_data[application_data["TARGET"]==0]["DAYS_EMPLOYED"],color="b")
plt.title("days employed distribution of repayers")

plt.subplot(122)
sns.distplot(application_data[application_data["TARGET"]==1]["DAYS_EMPLOYED"],color="r")
plt.title("days employed distribution of defaulters")

fig.set_facecolor("ghostwhite")

"""

*   **Distribution of registration days for target variable.**

*   DAYS_REGISTRATION How many days before the application did client change his registration"""

fig = plt.figure(figsize=(13,5))

plt.subplot(121)
sns.distplot(application_data[application_data["TARGET"]==0]["DAYS_REGISTRATION"],color="b")
plt.title("registration days distribution of repayers")

plt.subplot(122)
sns.distplot(application_data[application_data["TARGET"]==1]["DAYS_REGISTRATION"],color="r")
plt.title("registration days distribution of defaulter")

fig.set_facecolor("ghostwhite")

"""

*   **Distribution in contact information provided by client**
*   FLAG_MOBIL - Did client provide mobile phone (1=YES, 0=NO)

*   FLAG_EMP_PHONE - Did client provide work phone (1=YES, 0=NO)

*   FLAG_WORK_PHONE - Did client provide home phone (1=YES, 0=NO)

*   FLAG_CONT_MOBILE - Was mobile phone reachable (1=YES, 0=NO)
*   FLAG_PHONE - Did client provide home phone (1=YES, 0=NO)


*   FLAG_EMAIL - Did client provide email (1=YES, 0=NO)"""

x = application_data[['FLAG_MOBIL', 'FLAG_EMP_PHONE', 'FLAG_WORK_PHONE', 'FLAG_CONT_MOBILE',
       'FLAG_PHONE', 'FLAG_EMAIL', "TARGET"]]
x["TARGET"] = x["TARGET"].replace({0: "repayers", 1: "defaulters"})
x = x.replace({1: "YES", 0: "NO"})

cols = ['FLAG_MOBIL', 'FLAG_EMP_PHONE', 'FLAG_WORK_PHONE', 'FLAG_CONT_MOBILE',
        'FLAG_PHONE', 'FLAG_EMAIL']
length = len(cols)

fig = plt.figure(figsize=(15, 12))
fig.set_facecolor("lightgrey")

for i, j in itertools.zip_longest(cols, range(length)):
    plt.subplot(2, 3, j + 1)
    sns.countplot(x=x[i], hue=x["TARGET"], palette=["r", "g"])
    plt.title(i, color="b")

plt.tight_layout()
plt.show()

"""**Distribution of registration days for target variable**


*   Distribution of registration days for target variable.
REGION_RATING_CLIENT - Home credit rating of the region where client lives (1,2,3).
*   REGION_RATING_CLIENT_W_CITY - Home credit rating of the region where client lives with taking city into account (1,2,3). Percentage of defaulters are less in 1-rated regions compared to repayers.


"""

fig = plt.figure(figsize=(13,13))
plt.subplot(221)
application_data[application_data["TARGET"]==0]["REGION_RATING_CLIENT"].value_counts().plot.pie(autopct = "%1.0f%%",fontsize=12,
                                                             colors = sns.color_palette("Pastel1"),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True)

plt.title("Distribution of region rating  for Repayers",color="b")

plt.subplot(222)
application_data[application_data["TARGET"]==1]["REGION_RATING_CLIENT"].value_counts().plot.pie(autopct = "%1.0f%%",fontsize=12,
                                                    colors = sns.color_palette("Pastel1"),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True)


plt.title("Distribution of region rating  for Defaulters",color="b")
plt.ylabel("")

plt.subplot(223)
application_data[application_data["TARGET"]==0]["REGION_RATING_CLIENT_W_CITY"].value_counts().plot.pie(autopct = "%1.0f%%",fontsize=12,
                                                             colors = sns.color_palette("Paired"),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True)

plt.title("Distribution of city region rating   for Repayers",color="b")

plt.subplot(224)
application_data[application_data["TARGET"]==1]["REGION_RATING_CLIENT_W_CITY"].value_counts().plot.pie(autopct = "%1.0f%%",fontsize=12,
                                                    colors = sns.color_palette("Paired"),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True)


plt.title("Distribution of city region rating  for Defaulters",color="b")
plt.ylabel("")
fig.set_facecolor("ivory")

"""

*   Percentage of defaulters are less in 1-rated regions compared to repayers.
*   Percentage of defaulters are more in 3-rated regions compared to repayers
**Peak days and hours for applying loans (defaulters vs repayers)**

*   WEEKDAY_APPR_PROCESS_START - On which day of the week did the client apply for the loan.
*   HOUR_APPR_PROCESS_START - Approximately at what hour did the client apply for the loan."""

# Group by and value counts
day = application_data.groupby("TARGET").agg({"WEEKDAY_APPR_PROCESS_START":"value_counts"})
day = day.rename(columns={"WEEKDAY_APPR_PROCESS_START":"value_counts"}).reset_index()

# Separate by target value
day_0 = day[day["TARGET"]==0]
day_1 = day[day["TARGET"]==1]

# Calculate percentages
day_0["percentage"] = day_0["value_counts"] * 100 / day_0["value_counts"].sum()
day_1["percentage"] = day_1["value_counts"] * 100 / day_1["value_counts"].sum()

# Concatenate back
days = pd.concat([day_0, day_1], axis=0)

# Correct value replacement just in 'TARGET' column
days["TARGET"] = days["TARGET"].replace({1:"defaulters", 0:"repayers"})

# Plotting
fig = plt.figure(figsize=(13,15))

plt.subplot(211)
order = ['SUNDAY', 'MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY']
ax = sns.barplot(x="WEEKDAY_APPR_PROCESS_START", y="percentage", data=days,
                 hue="TARGET", order=order, palette="prism")
ax.set_facecolor("k")
ax.set_title("Peak days for applying loans (defaulters vs repayers)")

# Hour-wise grouping
hr = application_data.groupby("TARGET").agg({"HOUR_APPR_PROCESS_START":"value_counts"})
hr = hr.rename(columns={"HOUR_APPR_PROCESS_START":"value_counts"}).reset_index()

hr_0 = hr[hr["TARGET"]==0]
hr_1 = hr[hr["TARGET"]==1]

# Percentage calculation
hr_0["percentage"] = hr_0["value_counts"] * 100 / hr_0["value_counts"].sum()
hr_1["percentage"] = hr_1["value_counts"] * 100 / hr_1["value_counts"].sum()

# Combine
hrs = pd.concat([hr_0, hr_1], axis=0)
hrs["TARGET"] = hrs["TARGET"].replace({1:"defaulters", 0:"repayers"})
hrs = hrs.sort_values(by="HOUR_APPR_PROCESS_START", ascending=True)

plt.subplot(212)
ax1 = sns.pointplot(x="HOUR_APPR_PROCESS_START", y="percentage", data=hrs,
                    hue="TARGET", palette="prism")
ax1.set_facecolor("k")
ax1.set_title("Peak hours for applying loans (defaulters vs repayers)")

fig.set_facecolor("snow")
plt.tight_layout()
plt.show()

"""

*   On tuesdays , percentage of defaulters applying for loans is greater than that of repayers.
*   From morning 4'O clock to 9'O clock percentage of defaulters applying for loans is greater than that of repayers

**Distribution in organization types for repayers and defaulters**


*   ORGANIZATION_TYPE - Type of organization where client works"""

org = application_data.groupby("TARGET").agg({"ORGANIZATION_TYPE":"value_counts"})
org = org.rename(columns = {"ORGANIZATION_TYPE":"value_counts"}).reset_index()
org_0 = org[org["TARGET"] == 0]
org_1 = org[org["TARGET"] == 1]
org_0["percentage"] = org_0["value_counts"]*100/org_0["value_counts"].sum()
org_1["percentage"] = org_1["value_counts"]*100/org_1["value_counts"].sum()

organization = pd.concat([org_0,org_1],axis=0)
organization = organization.sort_values(by="ORGANIZATION_TYPE",ascending=True)

organization["TARGET"] = organization["TARGET"].replace({0:"repayers",1:"defaulters"})

organization
plt.figure(figsize=(13,7))
ax = sns.pointplot(x= "ORGANIZATION_TYPE", y="percentage",
                   data=organization,hue="TARGET",palette=["b","r"])
plt.xticks(rotation=90)
plt.grid(True,alpha=.3)
ax.set_facecolor("k")
ax.set_title("Distribution in organization types for repayers and defaulters")
plt.show()

"""

*   Organizations like Business Entity Type 3,Construction,Self-employed percentage of defaulters are higher than repayers.

**Distribution client's social surroundings with observed and defaulted 30 DPD (days past due)**


*   OBS_30_CNT_SOCIAL_CIRCLE- How many observation of client's social surroundings with observable 30 DPD (days past due) defaul

*   DEF_30_CNT_SOCIAL_CIRCLE-How many observation of client's social surroundings defaulted on 30 DPD (days past due) .
*   OBS_60_CNT_SOCIAL_CIRCLE - How many observation of client's social surroundings with observable 60 DPD (days past due) default.


*   DEF_60_CNT_SOCIAL_CIRCLE - How many observation of client's social surroundings defaulted on 60 (days past due) DPD.


"""

fig = plt.figure(figsize=(20,20))
plt.subplot(421)
sns.boxplot(data=application_data,x='TARGET',y='OBS_30_CNT_SOCIAL_CIRCLE',
            hue="TARGET", palette="Set3")
plt.title("Client's social surroundings with observable 30 DPD (days past due) def",color="b")
plt.subplot(422)
sns.boxplot(data=application_data,x='TARGET',y='DEF_30_CNT_SOCIAL_CIRCLE',
            hue="TARGET", palette="Set3")
plt.title("Client's social surroundings defaulted on 30 DPD (days past due)",color="b")
plt.subplot(423)
sns.boxplot(data=application_data,x='TARGET',y='OBS_60_CNT_SOCIAL_CIRCLE',
            hue="TARGET", palette="Set3")
plt.title("Client's social surroundings with observable 60 DPD (days past due) default",color="b")
plt.subplot(424)
sns.boxplot(data=application_data,x='TARGET',y='DEF_60_CNT_SOCIAL_CIRCLE',
            hue="TARGET", palette="Set3")
plt.title("Client's social surroundings defaulted on 60 DPD (days past due)",color="b")
fig.set_facecolor("ghostwhite")

"""**Number of days before application client changed phone .**


*   DAYS_LAST_PHONE_CHANGE - How many days before application did client change phone.


"""

plt.figure(figsize=(13,7))
plt.subplot(121)
ax = sns.violinplot(x= application_data["TARGET"],
                    y=application_data["DAYS_LAST_PHONE_CHANGE"],palette=["g","r"])
ax.set_facecolor("oldlace")
ax.set_title("days before application client changed phone -violin plot")
plt.subplot(122)
ax1 = sns.boxplot(x=application_data["TARGET"],
                 y=application_data["DAYS_LAST_PHONE_CHANGE"],palette=["g","r"])
ax1.set_facecolor("oldlace")
ax1.set_ylabel("")
ax1.set_title("days before application client changed phone -box plot")
plt.subplots_adjust(wspace = .2)

"""

*   Average days of defaulters phone change is less than average days of repayers phone change.
**Documents provided by the clients**


*   FLAG_DOCUMENT - Did client provide documents.(1,0)"""

cols = [ 'FLAG_DOCUMENT_2', 'FLAG_DOCUMENT_3',
       'FLAG_DOCUMENT_4', 'FLAG_DOCUMENT_5', 'FLAG_DOCUMENT_6',
       'FLAG_DOCUMENT_7', 'FLAG_DOCUMENT_8', 'FLAG_DOCUMENT_9',
       'FLAG_DOCUMENT_10', 'FLAG_DOCUMENT_11', 'FLAG_DOCUMENT_12',
       'FLAG_DOCUMENT_13', 'FLAG_DOCUMENT_14', 'FLAG_DOCUMENT_15',
       'FLAG_DOCUMENT_16', 'FLAG_DOCUMENT_17', 'FLAG_DOCUMENT_18',
       'FLAG_DOCUMENT_19', 'FLAG_DOCUMENT_20', 'FLAG_DOCUMENT_21']

df_flag = application_data[cols+["TARGET"]]

length = len(cols)

df_flag["TARGET"] = df_flag["TARGET"].replace({1:"defaulter",0:"repayer"})

fig = plt.figure(figsize=(13,24))
fig.set_facecolor("lightgrey")
for i,j in itertools.zip_longest(cols,range(length)):
    plt.subplot(5,4,j+1)
    ax = sns.countplot(x= df_flag[i], hue=df_flag["TARGET"],palette=["r","b"])
    plt.yticks(fontsize=5)
    plt.xlabel("")
    plt.title(i)
    ax.set_facecolor("k")

"""
**Equiries to Credit Bureau about the client before application**
*   AMT_REQ_CREDIT_BUREAU_HOUR - Number of enquiries to Credit Bureau about the client one hour before application.
*   AMT_REQ_CREDIT_BUREAU_DAY - Number of enquiries to Credit Bureau about the client one day before application (excluding one hour before application).

*   AMT_REQ_CREDIT_BUREAU_WEEK - Number of enquiries to Credit Bureau about the client one week before application (excluding one day before application)
*   AMT_REQ_CREDIT_BUREAU_MON - Number of enquiries to Credit Bureau about the client one month before application (excluding one week before application).

*   AMT_REQ_CREDIT_BUREAU_QRT - Number of enquiries to Credit Bureau about the client 3 month before application (excluding one month before application).
*   AMT_REQ_CREDIT_BUREAU_YEAR - Number of enquiries to Credit Bureau about the client one day year (excluding last 3 months before application)."""

cols = ['AMT_REQ_CREDIT_BUREAU_HOUR', 'AMT_REQ_CREDIT_BUREAU_DAY',
       'AMT_REQ_CREDIT_BUREAU_WEEK', 'AMT_REQ_CREDIT_BUREAU_MON',
       'AMT_REQ_CREDIT_BUREAU_QRT', 'AMT_REQ_CREDIT_BUREAU_YEAR']
application_data.groupby("TARGET")[cols].max().transpose().plot(kind="barh",
                                                                 figsize=(10,5),width=.8)
plt.title("Maximum enquries made by defaulters and repayers")
application_data.groupby("TARGET")[cols].mean().transpose().plot(kind="barh",
                                                                  figsize=(10,5),width=.8)
plt.title("average enquries made by defaulters and repayers")
application_data.groupby("TARGET")[cols].std().transpose().plot(kind="barh",
                                                                 figsize=(10,5),width=.8)
plt.title("standard deviation in enquries made by defaulters and repayers")
plt.show()

"""**Current loan id having previous loan applications**


*   SK_ID_PREV - ID of previous credit in Home credit related to loan in our sample. (One loan in our sample can have 0,1,2 or more previous loan applications in Home Credit, previous application could, but not necessarily have to lead to credit).
*   SK_ID_CURR ID of loan in our sample.


"""

x = previous_application.groupby("SK_ID_CURR")["SK_ID_PREV"].count().reset_index()
plt.figure(figsize=(13,7))
ax = sns.distplot(x["SK_ID_PREV"],color="orange")
plt.axvline(x["SK_ID_PREV"].mean(),linestyle="dashed",color="r",label="average")
plt.axvline(x["SK_ID_PREV"].std(),linestyle="dashed",color="b",label="standard deviation")
plt.axvline(x["SK_ID_PREV"].max(),linestyle="dashed",color="g",label="maximum")
plt.legend(loc="best")
plt.title("Current loan id having previous loan applications")
ax.set_facecolor("k")

"""

*   On average current loan ids have 4 to 5 loan applications previously

**Contract types in previous applications**
*   NAME_CONTRACT_TYPE Contract product type (Cash loan, consumer loan [POS] ,...) of the previous application.

"""

cnts = previous_application["NAME_CONTRACT_TYPE"].value_counts()
import squarify
plt.figure(figsize=(8,6))
squarify.plot(cnts.values,label=cnts.keys(),value=cnts.values,linewidth=2,edgecolor="k",alpha=.8,color=sns.color_palette("Set1"))
plt.axis("off")
plt.title("Contaract types in previous applications")
plt.show()

"""

*   Cash loan applications are maximum followed by consumer loan applications
**Previous loan amounts applied and loan amounts credited**
*   AMT_APPLICATION-For how much credit did client ask on the previous application

*   AMT_CREDIT-Final credit amount on the previous application. This differs from AMT_APPLICATION in a way that the AMT_APPLICATION is the amount for which the client initially applied for, but during our approval process he could have received different amount - AMT_CREDIT.


"""

plt.figure(figsize=(20,20))
plt.subplot(211)
ax = sns.kdeplot(previous_application["AMT_APPLICATION"],color="b",linewidth=3)
ax = sns.kdeplot(previous_application[previous_application["AMT_CREDIT"].notnull()]["AMT_CREDIT"],color="r",linewidth=3)
plt.axvline(previous_application[previous_application["AMT_CREDIT"].notnull()]["AMT_CREDIT"].mean(),color="r",linestyle="dashed",label="AMT_APPLICATION_MEAN")
plt.axvline(previous_application["AMT_APPLICATION"].mean(),color="b",linestyle="dashed",label="AMT_APPLICATION_MEAN")
plt.legend(loc="best")
plt.title("Previous loan amounts applied and loan amounts credited.")
ax.set_facecolor("k")

plt.subplot(212)
diff = (previous_application["AMT_CREDIT"] - previous_application["AMT_APPLICATION"]).reset_index()
diff = diff[diff[0].notnull()]
ax1 = sns.kdeplot(diff[0],color="g",linewidth=3,label = "difference in amount requested by client and amount credited")
plt.axvline(diff[0].mean(),color="white",linestyle="dashed",label = "mean")
plt.title("difference in amount requested by client and amount credited")
ax1.legend(loc="best")
ax1.set_facecolor("k")

"""**Total and average amounts applied and credited in previous applications**


*   AMT_APPLICATION-For how much credit did client ask on the previous application. >AMT_CREDIT-Final credit amount on the previous application. This differs from AMT_APPLICATION in a way that the AMT_APPLICATION is the amount for which the client.


"""

mn = previous_application.groupby("NAME_CONTRACT_TYPE")[["AMT_APPLICATION","AMT_CREDIT"]].mean().stack().reset_index()
tt = previous_application.groupby("NAME_CONTRACT_TYPE")[["AMT_APPLICATION","AMT_CREDIT"]].sum().stack().reset_index()
fig = plt.figure(figsize=(10,13))
fig.set_facecolor("ghostwhite")
plt.subplot(211)
ax = sns.barplot(x=0, y="NAME_CONTRACT_TYPE",data=mn[:6],hue="level_1",palette="inferno")
ax.set_facecolor("k")
ax.set_xlabel("average amounts")
ax.set_title("Average amounts by contract types")

plt.subplot(212)
ax1 = sns.barplot(x=0, y="NAME_CONTRACT_TYPE",data=tt[:6],hue="level_1",palette="magma")
ax1.set_facecolor("k")
ax1.set_xlabel("total amounts")
ax1.set_title("total amounts by contract types")
plt.subplots_adjust(hspace = .2)
plt.show()

"""**Annuity of previous application**


*   AMT_ANNUITY - Annuity of previous application
"""

plt.figure(figsize=(14,5))
plt.subplot(121)
previous_application.groupby("NAME_CONTRACT_TYPE")["AMT_ANNUITY"].sum().plot(kind="bar")
plt.xticks(rotation=0)
plt.title("Total annuity amount by contract types in previous applications")
plt.subplot(122)
previous_application.groupby("NAME_CONTRACT_TYPE")["AMT_ANNUITY"].mean().plot(kind="bar")
plt.title("average annuity amount by contract types in previous applications")
plt.xticks(rotation=0)
plt.show()

"""**Count of application status by application type**


*   NAME_CONTRACT_TYPE -Contract product type (Cash loan, consumer loan [POS] ,...) of the previous application.
*   NAME_CONTRACT_STATUS -Contract status (approved, cancelled, ...) of previous application.


"""

ax = pd.crosstab(previous_application["NAME_CONTRACT_TYPE"],previous_application["NAME_CONTRACT_STATUS"]).plot(kind="barh",figsize=(10,7),stacked=True)
plt.xticks(rotation =0)
plt.ylabel("count")
plt.title("Count of application status by application type")
ax.set_facecolor("k")

"""

*   Consumer loan applications are most approved loans and cash loans are most cancelled and refused loans.

**Contract status by weekdays**

* Contract status by weekdays"""

hr = pd.crosstab(previous_application["WEEKDAY_APPR_PROCESS_START"],previous_application["NAME_CONTRACT_STATUS"]).stack().reset_index()
plt.figure(figsize=(12,8))
ax = sns.pointplot(x= hr["WEEKDAY_APPR_PROCESS_START"], y=hr[0],hue=hr["NAME_CONTRACT_STATUS"],palette=["g","r","b","orange"],scale=1)
ax.set_facecolor("k")
ax.set_ylabel("count")
ax.set_title("Contract status by weekdays")
plt.grid(True,alpha=.2)

"""**Contract status by hour of the day**

*   HOUR_APPR_PROCESS_START - Approximately at what day hour did the client apply for the previous application


"""

hr = pd.crosstab(previous_application["HOUR_APPR_PROCESS_START"],previous_application["NAME_CONTRACT_STATUS"]).stack().reset_index()
plt.figure(figsize=(12,8))
ax = sns.pointplot(x= hr["HOUR_APPR_PROCESS_START"], y=hr[0],hue=hr["NAME_CONTRACT_STATUS"],palette=["g","r","b","orange"],scale=1)
ax.set_facecolor("k")
ax.set_ylabel("count")
ax.set_title("Contract status by day hours.")
plt.grid(True,alpha=.2)

"""

*   Morning 11'o clock have maximum number of approvals.


*   Morning 10'o clock have maximum number of refused and cancelled contracts.

**Peak hours for week days for applying loans**"""

hr = pd.crosstab(previous_application["HOUR_APPR_PROCESS_START"],previous_application["WEEKDAY_APPR_PROCESS_START"]).stack().reset_index()
plt.figure(figsize=(12,8))
ax = sns.pointplot(x= hr["HOUR_APPR_PROCESS_START"], y=hr[0],hue=hr["WEEKDAY_APPR_PROCESS_START"],palette=["g","r","b","orange"],scale=1)
ax.set_facecolor("k")
ax.set_ylabel("count")
ax.set_title("Peak hours for week days")
plt.grid(True,alpha=.2)

"""**Percentage of applications accepted,cancelled,refused and unused for different loan purposes**


*   NAME_CASH_LOAN_PURPOSE - Purpose of the cash loan.
*   NAME_CONTRACT_STATUS - Contract status (approved, cancelled, ...) of previous application.


"""

previous_application[["NAME_CASH_LOAN_PURPOSE","NAME_CONTRACT_STATUS"]]
purpose = pd.crosstab(previous_application["NAME_CASH_LOAN_PURPOSE"],previous_application["NAME_CONTRACT_STATUS"])
purpose["a"] = (purpose["Approved"]*100)/(purpose["Approved"]+purpose["Canceled"]+purpose["Refused"]+purpose["Unused offer"])
purpose["c"] = (purpose["Canceled"]*100)/(purpose["Approved"]+purpose["Canceled"]+purpose["Refused"]+purpose["Unused offer"])
purpose["r"] = (purpose["Refused"]*100)/(purpose["Approved"]+purpose["Canceled"]+purpose["Refused"]+purpose["Unused offer"])
purpose["u"] = (purpose["Unused offer"]*100)/(purpose["Approved"]+purpose["Canceled"]+purpose["Refused"]+purpose["Unused offer"])
purpose_new = purpose[["a","c","r","u"]]
purpose_new = purpose_new.stack().reset_index()
purpose_new["NAME_CONTRACT_STATUS"] = purpose_new["NAME_CONTRACT_STATUS"].replace({"a":"accepted_percentage","c":"cancelled_percentage",
                                                               "r":"refused_percentage","u":"unused_percentage"})

lst = purpose_new["NAME_CONTRACT_STATUS"].unique().tolist()
length = len(lst)
cs = ["lime","orange","r","b"]

fig = plt.figure(figsize=(14,18))
fig.set_facecolor("lightgrey")
for i,j,k in itertools.zip_longest(lst,range(length),cs):
    plt.subplot(2,2,j+1)
    dat = purpose_new[purpose_new["NAME_CONTRACT_STATUS"] == i]
    ax = sns.barplot(x=0, y="NAME_CASH_LOAN_PURPOSE",data=dat.sort_values(by=0,ascending=False),color=k)
    plt.ylabel("")
    plt.xlabel("percentage")
    plt.title(i+" by purpose")
    plt.subplots_adjust(wspace = .7)
    ax.set_facecolor("k")

"""* Purposes like XAP ,electronic eqipment ,everey day expences and education have maximum loan acceptance.

* Loan puposes like payment of other loans ,refusal to name goal ,buying new home or car have most refusals.

* 40% of XNA purpose loans are cancalled.
**Contract status relative to decision made about previous application**
* DAYS_DECISION - Relative to current application when was the decision about previous application made.
"""

plt.figure(figsize=(13,6))
sns.violinplot(y= previous_application["DAYS_DECISION"],
               x = previous_application["NAME_CONTRACT_STATUS"],palette=["r","g","b","y"])
plt.axhline(previous_application[previous_application["NAME_CONTRACT_STATUS"] == "Approved"]["DAYS_DECISION"].mean(),
            color="r",linestyle="dashed",label="accepted_average")
plt.axhline(previous_application[previous_application["NAME_CONTRACT_STATUS"] == "Refused"]["DAYS_DECISION"].mean(),
            color="g",linestyle="dashed",label="refused_average")
plt.axhline(previous_application[previous_application["NAME_CONTRACT_STATUS"] == "Cancelled"]["DAYS_DECISION"].mean(),color="b",
            linestyle="dashed",label="cancelled_average")
plt.axhline(previous_application[previous_application["NAME_CONTRACT_STATUS"] == "Unused offer"]["DAYS_DECISION"].mean(),color="y",
            linestyle="dashed",label="un used_average")
plt.legend(loc="best")

plt.title("Contract status relative to decision made about previous application.")
plt.show()

"""* On average approved contract types have higher number of decision days compared to cancelled and refused contracts.

**Client payment methods & reasons for application rejections**
* NAME_PAYMENT_TYPE - Payment method that client chose to pay for the previous application.

* CODE_REJECT_REASON - Why was the previous application rejected.
"""

plt.figure(figsize=(8,12))

# First plot: Reasons for rejection
plt.subplot(211)
rej = previous_application["CODE_REJECT_REASON"].value_counts().reset_index()
rej.columns = ["CODE_REJECT_REASON_TYPE", "COUNT"]
ax = sns.barplot(x="COUNT", y="CODE_REJECT_REASON_TYPE", data=rej[:6], palette="husl")

for i, j in enumerate(np.around((rej["COUNT"][:6].values * 100 / rej["COUNT"][:6].sum()))):
    ax.text(0.7 * rej["COUNT"].max(), i, f"{j:.0f}%", weight="bold", color="black")

plt.xlabel("Top as percentage & Bottom as Count")
plt.ylabel("CODE_REJECT_REASON")
plt.title("Reasons for application rejections")

# Second plot: Payment methods
plt.subplot(212)
pay = previous_application["NAME_PAYMENT_TYPE"].value_counts().reset_index()
pay.columns = ["NAME_PAYMENT_TYPE", "COUNT"]
ax1 = sns.barplot(x="COUNT", y="NAME_PAYMENT_TYPE", data=pay, palette="husl")

for i, j in enumerate(np.around((pay["COUNT"].values * 100 / pay["COUNT"].sum()))):
    ax1.text(0.7 * pay["COUNT"].max(), i, f"{j:.0f}%", weight="bold", color="black")

plt.xlabel("Top as percentage & Bottom as Count")
plt.ylabel("NAME_PAYMENT_TYPE")
plt.title("Clients payment methods")

plt.subplots_adjust(hspace=0.3)
plt.show()

"""* Around 81% of rejected applications the reason is XAP.

* 62% of chose to pay through cash by bank for previous applications.

**Distribution in Client suite type & client type.**
* NAME_TYPE_SUITE - Who accompanied client when applying for the previous application.

* NAME_CLIENT_TYPE - Was the client old or new client when applying for the previous application.
"""

plt.figure(figsize=(20,20))
plt.subplot(121)
previous_application["NAME_TYPE_SUITE"].value_counts().plot.pie(autopct = "%1.1f%%",fontsize=12,
                                                             colors = sns.color_palette("inferno"),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True)
circ = plt.Circle((0,0),.7,color="white")
plt.gca().add_artist(circ)
plt.title("NAME_TYPE_SUITE")

plt.subplot(122)
previous_application["NAME_CLIENT_TYPE"].value_counts().plot.pie(autopct = "%1.1f%%",fontsize=12,
                                                             colors = sns.color_palette("inferno"),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True)
circ = plt.Circle((0,0),.7,color="white")
plt.gca().add_artist(circ)
plt.title("NAME_CLIENT_TYPE")
plt.show()

"""* About 60% clients are un-accompained when applying for loans.

* 73% clients are old clients

**Popular goods for applying loans**
* NAME_GOODS_CATEGORY - What kind of goods did the client apply for in the previous application.
"""

goods = previous_application["NAME_GOODS_CATEGORY"].value_counts().reset_index()
goods.columns = ["NAME_GOODS_CATEGORY", "COUNT"]
goods["percentage"] = round(goods["COUNT"] * 100 / goods["COUNT"].sum(), 2)

fig = plt.figure(figsize=(12,5))
ax = sns.pointplot(x="NAME_GOODS_CATEGORY", y="percentage", data=goods, color="yellow")
plt.xticks(rotation=80)
plt.xlabel("NAME_GOODS_CATEGORY")
plt.ylabel("Percentage")
plt.title("Popular goods for applying loans")
ax.set_facecolor("k")
fig.set_facecolor('lightgrey')
plt.show()

"""* XNA ,Mobiles ,Computers and consumer electronics are popular goods for applying loans

**Previous applications portfolio and product types**
* NAME_PORTFOLIO - Was the previous application for CASH, POS, CAR, ‚Ä¶

* NAME_PRODUCT_TYPE - Was the previous application x-sell o walk-in.
"""

plt.figure(figsize=(20,20))
plt.subplot(121)
previous_application["NAME_PORTFOLIO"].value_counts().plot.pie(autopct = "%1.1f%%",fontsize=12,
                                                             colors = sns.color_palette("prism",5),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},
                                                               shadow =True)
plt.title("previous applications portfolio")
plt.subplot(122)
previous_application["NAME_PRODUCT_TYPE"].value_counts().plot.pie(autopct = "%1.1f%%",fontsize=12,
                                                             colors = sns.color_palette("prism",3),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},
                                                                  shadow =True)
plt.title("previous applications product types")
plt.show()

"""**Approval,canceled and refusal rates by channel types.**
* CHANNEL_TYPE - Through which channel we acquired the client on the previous application.

* NAME_CONTRACT_STATUS- Contract status (approved, cancelled, ...) of previous application.
"""

app = pd.crosstab(previous_application["CHANNEL_TYPE"],previous_application["NAME_CONTRACT_STATUS"])
app1 = app
app1["approval_rate"] = app1["Approved"]*100/(app1["Approved"]+app1["Refused"]+app1["Canceled"])
app1["refused_rate"]  = app1["Refused"]*100/(app1["Approved"]+app1["Refused"]+app1["Canceled"])
app1["cacelled_rate"] = app1["Canceled"]*100/(app1["Approved"]+app1["Refused"]+app1["Canceled"])
app2 = app[["approval_rate","refused_rate","cacelled_rate"]]
ax = app2.plot(kind="barh",stacked=True,figsize=(10,7))
ax.set_facecolor("k")
ax.set_xlabel("percentage")
ax.set_title("approval,cancel and refusal rates by channel types")
plt.show()

"""* Channel types like Stone ,regional and country-wide have maximum approval rates.

*  Channel of coorporate sales have maximum refusal rate.

* Credit-cash centres and Contact centres have maximum cancellation rates.

**Highest amount credited seller areas and industries.**
* SELLERPLACE_AREA - Selling area of seller place of the previous application.

* NAME_SELLER_INDUSTRY - The industry of the seller.
"""

fig = plt.figure(figsize=(13,5))
plt.subplot(121)
are = previous_application.groupby("SELLERPLACE_AREA")["AMT_CREDIT"].sum().reset_index()
are = are.sort_values(by ="AMT_CREDIT",ascending = False)
ax = sns.barplot(y= "AMT_CREDIT",x ="SELLERPLACE_AREA",data=are[:15],color="r")
ax.set_facecolor("k")
ax.set_title("Highest amount credited seller place areas")

plt.subplot(122)
sell = previous_application.groupby("NAME_SELLER_INDUSTRY")["AMT_CREDIT"].sum().reset_index().sort_values(by = "AMT_CREDIT",ascending = False)
ax1=sns.barplot(y = "AMT_CREDIT",x = "NAME_SELLER_INDUSTRY",data=sell,color="b")
ax1.set_facecolor("k")
ax1.set_title("Highest amount credited seller industrys")
plt.xticks(rotation=90)
plt.subplots_adjust(wspace = .5)
fig.set_facecolor("lightgrey")

"""**Popular terms of previous credit at application.**
* CNT_PAYMENT - Term of previous credit at application of the previous application.
"""

plt.figure(figsize=(13,5))
ax = sns.countplot(previous_application["CNT_PAYMENT"],palette="Set1",order=previous_application["CNT_PAYMENT"].value_counts().index)
ax.set_facecolor("k")
plt.xticks(rotation = 90)
plt.title("popular terms of previous credit at application")
plt.show()

"""* Popular term of previous credit are 6months ,10months ,1year ,2years & 3 years.

**Detailed product combination of the previous application**
"""

plt.figure(figsize=(10,8))
sns.countplot(y = previous_application["PRODUCT_COMBINATION"],order=previous_application["PRODUCT_COMBINATION"].value_counts().index)
plt.title("Detailed product combination of the previous application -count")
plt.show()

"""**Frequency distribution of intrest rates and client insurance requests**
* NAME_YIELD_GROUP - Grouped interest rate into small medium and high of the previous application.

* NFLAG_INSURED_ON_APPROVAL - Did the client requested insurance during the previous application.
"""

plt.figure(figsize=(12,6))
plt.subplot(121)
previous_application["NFLAG_INSURED_ON_APPROVAL"].value_counts().plot.pie(autopct = "%1.1f%%",fontsize=8,
                                                             colors = sns.color_palette("prism",4),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True)
circ = plt.Circle((0,0),.7,color="white")
plt.gca().add_artist(circ)
plt.title("client requesting insurance")

plt.subplot(122)
previous_application["NAME_YIELD_GROUP"].value_counts().plot.pie(autopct = "%1.1f%%",fontsize=8,
                                                             colors = sns.color_palette("prism",4),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True)
circ = plt.Circle((0,0),.7,color="white")
plt.gca().add_artist(circ)
plt.title("interest rates")
plt.show()

"""**Days variables - Relative to application date of current application**
* DAYS_FIRST_DRAWING - Relative to application date of current application when was the first disbursement of the previous application.

* DAYS_FIRST_DUE - Relative to application date of current application when was the first due supposed to be of the previous application.

* DAYS_LAST_DUE_1ST_VERSION - Relative to application date of current application when was the first due of the previous application.

* DAYS_LAST_DUE -Relative to application date of current application when was the last due date of the previous application.

* DAYS_TERMINATION - Relative to application date of current application when was the expected termination of the previous application.
"""

cols = ['DAYS_FIRST_DRAWING', 'DAYS_FIRST_DUE', 'DAYS_LAST_DUE_1ST_VERSION','DAYS_LAST_DUE', 'DAYS_TERMINATION']
plt.figure(figsize=(12,6))
sns.heatmap(previous_application[cols].describe()[1:].transpose(),
            annot=True,linewidth=2,linecolor="k",cmap=sns.color_palette("inferno"))
plt.show()

"""# Corelation between variables

**Application Data**
"""

# Select only numeric columns
numeric_data = application_data.select_dtypes(include=["number"])

# Compute correlation matrix
corrmat = numeric_data.corr()

# Plot heatmap
f, ax = plt.subplots(figsize=(8, 8))
sns.heatmap(corrmat, ax=ax, cmap="rainbow")
plt.title("Correlation Matrix (Numeric Features Only)")
plt.show()

"""**Previous Application**"""

# Keep only numeric columns
numeric_data = previous_application.select_dtypes(include=["number"])

# Compute correlation matrix
corrmat = numeric_data.corr()

# Plot heatmap
f, ax = plt.subplots(figsize=(20, 20))
sns.heatmap(corrmat, annot=True, cmap="rainbow")
plt.title("Correlation Matrix (Previous Applications - Numeric Features Only)")
plt.show()

numeric_df = previous_application.select_dtypes(include=[np.number])
corrmat = numeric_df.corr()

corrdf = corrmat.where(np.triu(np.ones(corrmat.shape), k=1).astype(bool))  # updated np.bool to bool
corrdf = corrdf.unstack().reset_index()
corrdf.columns = ['Var1', 'Var2', 'Correlation']
corrdf.dropna(subset=['Correlation'], inplace=True)
corrdf['Correlation'] = corrdf['Correlation'].abs().round(2)
corrdf.sort_values(by='Correlation', ascending=False).head(10)

corrmat = previous_application.corr()
corrdf = corrmat.where(np.triu(np.ones(corrmat.shape), k=1).astype(np.bool))
corrdf = corrdf.unstack().reset_index()
corrdf.columns = ['Var1', 'Var2', 'Correlation']
corrdf.dropna(subset = ['Correlation'], inplace = True)
corrdf['Correlation'] = round(corrdf['Correlation'], 2)
corrdf['Correlation'] = abs(corrdf['Correlation'])
corrdf.sort_values(by = 'Correlation', ascending = False).head(10)

if "TARGET" in numeric_data.columns:
    top_corr_features = corrmat["TARGET"].abs().sort_values(ascending=False).head(20).index
    top_corrmat = numeric_data[top_corr_features].corr()

    f, ax = plt.subplots(figsize=(10, 8))
    sns.heatmap(top_corrmat, annot=True, cmap="rainbow")
    plt.title("Top 20 Correlated Features (Previous Applications)")
    plt.show()

# Keep only numeric columns
numeric_data = previous_application.select_dtypes(include=["number"])

# Compute correlation matrix
corrmat = numeric_data.corr()

# Extract upper triangle of the correlation matrix
corrdf = corrmat.where(np.triu(np.ones(corrmat.shape), k=1).astype(bool))

# Reshape into long format
corrdf = corrdf.unstack().reset_index()
corrdf.columns = ['Var1', 'Var2', 'Correlation']

# Drop missing values
corrdf.dropna(subset=['Correlation'], inplace=True)

# Absolute correlation values
corrdf['Correlation'] = round(corrdf['Correlation'].abs(), 2)

# Show top 10 correlations
corrdf.sort_values(by='Correlation', ascending=False).head(10)

"""# Application Data
**Top 10 Correlation Fields for Repayer**
"""

df_repayer = application_data[application_data['TARGET'] == 0]
df_defaulter = application_data[application_data['TARGET'] == 1]

# Keep only numeric columns
numeric_data = df_repayer.select_dtypes(include=["number"])

# Compute correlation matrix
corrmat = numeric_data.corr()

# Extract upper triangle of the correlation matrix
corrdf = corrmat.where(np.triu(np.ones(corrmat.shape), k=1).astype(bool))

# Reshape into long format
corrdf = corrdf.unstack().reset_index()
corrdf.columns = ['Var1', 'Var2', 'Correlation']

# Drop NaNs
corrdf.dropna(subset=['Correlation'], inplace=True)

# Absolute correlation values, rounded
corrdf['Correlation'] = round(corrdf['Correlation'].abs(), 2)

# Show top 10 correlations
corrdf.sort_values(by='Correlation', ascending=False).head(10)

"""**Top 10 Correlation Fields for Defaulter**"""

# Keep only numeric columns
numeric_data = df_defaulter.select_dtypes(include=["number"])

# Compute correlation matrix
corrmat = numeric_data.corr()

# Extract upper triangle
corrdf = corrmat.where(np.triu(np.ones(corrmat.shape), k=1).astype(bool))

# Reshape to long form
corrdf = corrdf.unstack().reset_index()
corrdf.columns = ['Var1', 'Var2', 'Correlation']

# Drop NaNs
corrdf.dropna(subset=['Correlation'], inplace=True)

# Take absolute value and round
corrdf['Correlation'] = round(corrdf['Correlation'].abs(), 2)

# Show top 10 correlations
corrdf.sort_values(by='Correlation', ascending=False).head(10)

mergeddf =  pd.merge(application_data,previous_application,on='SK_ID_CURR')
mergeddf.head()

y = mergeddf.groupby('SK_ID_CURR').size()
dfA = mergeddf.groupby('SK_ID_CURR').agg({'TARGET': np.sum})
dfA['count'] = y
display(dfA.head(10))

dfA.sort_values(by = 'count',ascending=False).head(10)

df_repayer = dfA[dfA['TARGET'] == 0]
df_defaulter = dfA[dfA['TARGET'] == 1]

"""**Repayers' Borrowing History**"""

df_repayer.sort_values(by = 'count',ascending=False).head(10)

"""**Defaulters' Borrowing History**"""

df_defaulter.sort_values(by = 'count',ascending=False).head(10)

#application_data=application_data.drop([ 'EXT_SOURCE_1', 'EXT_SOURCE_2', 'EXT_SOURCE_3','APARTMENTS_AVG', 'BASEMENTAREA_AVG', 'YEARS_BEGINEXPLUATATION_AVG','YEARS_BUILD_AVG', 'COMMONAREA_AVG', 'ELEVATORS_AVG', 'ENTRANCES_AVG','FLOORSMAX_AVG','FLOORSMIN_AVG', 'LANDAREA_AVG','LIVINGAPARTMENTS_AVG', 'LIVINGAREA_AVG', 'NONLIVINGAPARTMENTS_AVG','NONLIVINGAREA_AVG', 'APARTMENTS_MODE', 'BASEMENTAREA_MODE','YEARS_BEGINEXPLUATATION_MODE', 'YEARS_BUILD_MODE', 'COMMONAREA_MODE','ELEVATORS_MODE', 'ENTRANCES_MODE', 'FLOORSMAX_MODE', 'FLOORSMIN_MODE','LANDAREA_MODE', 'LIVINGAPARTMENTS_MODE', 'LIVINGAREA_MODE','NONLIVINGAPARTMENTS_MODE', 'NONLIVINGAREA_MODE', 'APARTMENTS_MEDI','BASEMENTAREA_MEDI', 'YEARS_BEGINEXPLUATATION_MEDI', 'YEARS_BUILD_MEDI','COMMONAREA_MEDI', 'ELEVATORS_MEDI', 'ENTRANCES_MEDI', 'FLOORSMAX_MEDI','FLOORSMIN_MEDI', 'LANDAREA_MEDI', 'LIVINGAPARTMENTS_MEDI','LIVINGAREA_MEDI', 'NONLIVINGAPARTMENTS_MEDI', 'NONLIVINGAREA_MEDI','FONDKAPREMONT_MODE', 'HOUSETYPE_MODE', 'TOTALAREA_MODE','WALLSMATERIAL_MODE', 'EMERGENCYSTATE_MODE',"OWN_CAR_AGE","OCCUPATION_TYPE"],axis=1)
#previous_application=previous_application.drop([ 'AMT_DOWN_PAYMENT', 'RATE_DOWN_PAYMENT', 'RATE_INTEREST_PRIMARY',"RATE_INTEREST_PRIVILEGED"],axis=1)

pd.set_option("display.max_rows", None, "display.max_columns", None)
combined_df= pd.merge(application_data, previous_application, on='SK_ID_CURR', how='inner')

combined_df.sort_values(by=['SK_ID_CURR','SK_ID_PREV'],ascending=[True,True],inplace=True)
display(combined_df.head(10))

combined_df.drop_duplicates(subset='SK_ID_CURR',inplace=True,keep='last')
combined_df.head()

#combined_df.drop(['NAME_CONTRACT_TYPE_x'])

#combined_df.drop(['NAME_CONTRACT_TYPE_x'], axis=1, errors='ignore')

combined_df.columns

"""# Converting negative values to absolute values"""

combined_df['DAYS_BIRTH'] = abs(combined_df['DAYS_BIRTH'])
combined_df['DAYS_ID_PUBLISH'] = abs(combined_df['DAYS_ID_PUBLISH'])
combined_df['DAYS_ID_PUBLISH'] = abs(combined_df['DAYS_ID_PUBLISH'])
combined_df['DAYS_LAST_PHONE_CHANGE'] = abs(combined_df['DAYS_LAST_PHONE_CHANGE'])

"""# Corelation between variables"""

corrmat = combined_df.corr()

f, ax = plt.subplots(figsize =(8, 8))
sns.heatmap(corrmat, ax = ax, cmap ="rainbow")
plt.show()

corrmat = combined_df.corr()
corrdf = corrmat.where(np.triu(np.ones(corrmat.shape), k=1).astype(np.bool))
corrdf = corrdf.unstack().reset_index()
corrdf.columns = ['Var1', 'Var2', 'Correlation']
corrdf.dropna(subset = ['Correlation'], inplace = True)
corrdf['Correlation'] = round(corrdf['Correlation'], 2)
corrdf['Correlation'] = abs(corrdf['Correlation'])
corrdf.sort_values(by = 'Correlation', ascending = False).head(10)

"""# Imbalace percentage"""

fig = plt.figure(figsize=(13,6))
plt.subplot(121)
combined_df["CODE_GENDER"].value_counts().plot.pie(autopct = "%1.0f%%",colors = ["red","yellow"],startangle = 60,
                                                                        wedgeprops={"linewidth":2,"edgecolor":"k"},explode=[.05,0,0],shadow =True)
plt.title("Distribution of gender")
plt.show()

"""* It's non balanced data

**Distribution of Target variable**
* TARGET :Target variable (1 - client with payment difficulties: he/she had late payment more than X days on at least one of the first Y installments of the loan in sample, 0 - all other cases)
"""

plt.figure(figsize=(14,7))
plt.subplot(121)
combined_df["TARGET"].value_counts().plot.pie(autopct = "%1.0f%%",colors = sns.color_palette("prism",7),startangle = 60,labels=["repayer","defaulter"],
                                                                        wedgeprops={"linewidth":2,"edgecolor":"k"},explode=[.1,0],shadow =True)
plt.title("Distribution of target variable")

plt.subplot(122)
ax = combined_df["TARGET"].value_counts().plot(kind="barh")

for i,j in enumerate(combined_df["TARGET"].value_counts().values):
    ax.text(.7,i,j,weight = "bold",fontsize=20)

plt.title("Count of target variable")
plt.show()

"""* 8% out of total client population have difficulties in repaying loans.

**Distribution in Contract types**
* NAME_CONTRACT_TYPE : Identification if loan is cash , consumer or revolving
"""

plt.figure(figsize=(14,7))
plt.subplot(121)
combined_df["NAME_CONTRACT_TYPE_x"].value_counts().plot.pie(autopct = "%1.0f%%",colors = ["orange","red"],startangle = 60,
                                                                        wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True)
circ = plt.Circle((0,0),.7,color="white")
plt.gca().add_artist(circ)
plt.title("distribution of contract types in combined_df")

plt.show()

"""* The percentage of revolving loans and cash loans are 9% & 91%.

**Gender Distribution**
"""

fig = plt.figure(figsize=(13,6))
plt.subplot(121)
combined_df["CODE_GENDER"].value_counts().plot.pie(autopct = "%1.0f%%",colors = ["red","yellow"],startangle = 60,
                                                                        wedgeprops={"linewidth":2,"edgecolor":"k"},explode=[.05,0,0],shadow =True)
plt.title("Distribution of gender")
plt.show()

"""* Female : 66%

* Male : 34%

**Distribution of Contract type by gender**
"""

fig  = plt.figure(figsize=(13,6))
plt.subplot(121)
ax = sns.countplot(x= "NAME_CONTRACT_TYPE_x",hue="CODE_GENDER",data=combined_df,palette=["r","b","g"])
ax.set_facecolor("lightgrey")
ax.set_title("Distribution of Contract type by gender -application_data")


plt.show()

"""* Cash loans is always prefered over Revolving loans by both genders

**Distribution of client owning a car and by gender**
* FLAG_OWN_CAR Flag if the client owns a car .
"""

fig = plt.figure(figsize=(13,6))

plt.subplot(121)
combined_df["FLAG_OWN_CAR"].value_counts().plot.pie(autopct = "%1.0f%%",colors = ["gold","orangered"],startangle = 60,
                                                                        wedgeprops={"linewidth":2,"edgecolor":"k"},explode=[.05,0],shadow =True)
plt.title("distribution of client owning a car")

plt.subplot(122)
combined_df[combined_df["FLAG_OWN_CAR"] == "Y"]["CODE_GENDER"].value_counts().plot.pie(autopct = "%1.0f%%",colors = ["b","orangered"],startangle = 90,
                                                                        wedgeprops={"linewidth":2,"edgecolor":"k"},explode=[.05,0,0],shadow =True)
plt.title("distribution of client owning a car by gender")

plt.show()

"""* SUBPLOT 1 : Distribution of client owning a car. 34% of clients own a car .

* SUBPLOT 2 : Distribution of client owning a car by gender. Out of total
* clients who own car 57% are male and 43% are female.

**Distribution of client owning a house or flat and by gender**
* FLAG_OWN_REALTY - Flag if client owns a house or flat
"""

plt.figure(figsize=(13,6))
plt.subplot(121)
combined_df["FLAG_OWN_REALTY"].value_counts().plot.pie(autopct = "%1.0f%%",colors = ["skyblue","gold"],startangle = 90,
                                              wedgeprops={"linewidth":2,"edgecolor":"k"},explode=[0.05,0],shadow =True)
plt.title("Distribution of client owns a house or flat")

plt.subplot(122)
combined_df[combined_df["FLAG_OWN_REALTY"] == "Y"]["CODE_GENDER"].value_counts().plot.pie(autopct = "%1.0f%%",colors = ["orangered","b"],startangle = 90,
                                                                        wedgeprops={"linewidth":2,"edgecolor":"k"},explode=[.05,0,0],shadow =True)
plt.title("Distribution of client owning a house or flat by gender")
plt.show()

"""* SUBPLOT 1 : Distribution of client owning a house or flat . 71% of clients own a flat or house .

* SUBPLOT 2 : Distribution of client owning a house or flat by gender . Out of total clients who own house 67% are female and 33% are male.

**Distribution of Number of children and family members of client by repayment status.**
* CNT_CHILDREN - Number of children the client has.

* CNT_FAM_MEMBERS - How many family members does client have.
"""

fig = plt.figure(figsize=(12,10))
plt.subplot(211)
sns.countplot(x=combined_df["CNT_CHILDREN"],palette="Set1",hue=combined_df["TARGET"])
plt.legend(loc="upper center")
plt.title(" Distribution of Number of children client has  by repayment status")
plt.subplot(212)
sns.countplot(x=combined_df["CNT_FAM_MEMBERS"],palette="Set1",hue=combined_df["TARGET"])
plt.legend(loc="upper center")
plt.title(" Distribution of Number of family members client has  by repayment status")
fig.set_facecolor("lightblue")

"""# Distribution of contract type ,gender ,own car ,own house with respect to Repayment status(Target variable)"""

default = combined_df[combined_df["TARGET"]==1][[ 'NAME_CONTRACT_TYPE_x', 'CODE_GENDER','FLAG_OWN_CAR', 'FLAG_OWN_REALTY']]
non_default = combined_df[combined_df["TARGET"]==0][[ 'NAME_CONTRACT_TYPE_x', 'CODE_GENDER','FLAG_OWN_CAR', 'FLAG_OWN_REALTY']]

d_cols = ['NAME_CONTRACT_TYPE_x', 'CODE_GENDER','FLAG_OWN_CAR', 'FLAG_OWN_REALTY']
d_length = len(d_cols)

fig = plt.figure(figsize=(16,4))
for i,j in itertools.zip_longest(d_cols,range(d_length)):
    plt.subplot(1,4,j+1)
    default[i].value_counts().plot.pie(autopct = "%1.0f%%",colors = sns.color_palette("prism"),startangle = 90,
                                        wedgeprops={"linewidth":1,"edgecolor":"white"},shadow =True)
    circ = plt.Circle((0,0),.7,color="white")
    plt.gca().add_artist(circ)
    plt.ylabel("")
    plt.title(i+"-Defaulter")


fig = plt.figure(figsize=(16,4))
for i,j in itertools.zip_longest(d_cols,range(d_length)):
    plt.subplot(1,4,j+1)
    non_default[i].value_counts().plot.pie(autopct = "%1.0f%%",colors = sns.color_palette("prism",3),startangle = 90,
                                           wedgeprops={"linewidth":1,"edgecolor":"white"},shadow =True)
    circ = plt.Circle((0,0),.7,color="white")
    plt.gca().add_artist(circ)
    plt.ylabel("")
    plt.title(i+"-Repayer")

"""* Percentage of males is 10% more in defaults than non defaulters.

* Percentage of Cash Loans is 3% more in defaults than Revolving Loans.

**Distribution of amount data**
* AMT_INCOME_TOTAL - Income of the client

* AMT_CREDIT - Credit amount of the loan

* AMT_ANNUITY - Loan annuity

* AMT_GOODS_PRICE - For consumer loans it is the price of the goods for which the loan is given
"""

cols = [ 'AMT_INCOME_TOTAL', 'AMT_CREDIT_x','AMT_ANNUITY_x', 'AMT_GOODS_PRICE_x']
length = len(cols)
cs = ["r","b","g","k"]

ax = plt.figure(figsize=(18,18))
ax.set_facecolor("lightgrey")
for i,j,k in itertools.zip_longest(cols,range(length),cs):
    plt.subplot(2,2,j+1)
    sns.distplot(combined_df[combined_df[i].notnull()][i],color=k)
    plt.axvline(combined_df[i].mean(),label = "mean",linestyle="dashed",color="k")
    plt.legend(loc="best")
    plt.title(i)
    plt.subplots_adjust(hspace = .2)

"""# Comparing summary statistics between defaulters and non - defaulters for loan amounts."""

df = combined_df.groupby("TARGET")[cols].describe().transpose().reset_index()
df = df[df["level_1"].isin([ 'mean', 'std', 'min', 'max'])]
df_x = df[["level_0","level_1",0]]
df_y = df[["level_0","level_1",1]]
df_x = df_x.rename(columns={'level_0':"amount_type", 'level_1':"statistic", 0:"amount"})
df_x["type"] = "REPAYER"
df_y = df_y.rename(columns={'level_0':"amount_type", 'level_1':"statistic", 1:"amount"})
df_y["type"] = "DEFAULTER"
df_new = pd.concat([df_x,df_y],axis = 0)

stat = df_new["statistic"].unique().tolist()
length = len(stat)

plt.figure(figsize=(20,20))

for i,j in itertools.zip_longest(stat,range(length)):
    plt.subplot(2,2,j+1)
    fig = sns.barplot(x= df_new[df_new["statistic"] == i]["amount_type"], y=df_new[df_new["statistic"] == i]["amount"],
                hue=df_new[df_new["statistic"] == i]["type"],palette=["g","r"])
    plt.title(i + "--Defaulters vs Non defaulters")
    plt.subplots_adjust(hspace = .4)
    fig.set_facecolor("lightgrey")

"""**Income of client**

1.   Average income of clients who default and who do not are almost same.
2.   Standard deviation in income of client who default is very high compared to who do not default.

1.   Clients who default also has maximum income earnings

**Credit amount of the loan ,Loan annuity,Amount goods price**  

1.   Statistics between credit amounts,Loan annuity and Amount goods price given to cilents who default and who dont are almost similar
# Average Income,credit,annuity & goods_price by gender
"""

cols = [ 'AMT_INCOME_TOTAL', 'AMT_CREDIT_x','AMT_ANNUITY_x', 'AMT_GOODS_PRICE_x']

df1 = combined_df.groupby("CODE_GENDER")[cols].mean().transpose().reset_index()

df_f   = df1[["index","F"]]
df_f   = df_f.rename(columns={'index':"amt_type", 'F':"amount"})
df_f["gender"] = "FEMALE"
df_m   = df1[["index","M"]]
df_m   = df_m.rename(columns={'index':"amt_type", 'M':"amount"})
df_m["gender"] = "MALE"
df_xna = df1[["index","XNA"]]
df_xna = df_xna.rename(columns={'index':"amt_type", 'XNA':"amount"})
df_xna["gender"] = "XNA"

df_gen = pd.concat([df_m,df_f,df_xna],axis=0)

plt.figure(figsize=(12,5))
ax = sns.barplot(x="amt_type",y="amount",data=df_gen,hue="gender",palette="Set1")
plt.title("Average Income,credit,annuity & goods_price by gender")
plt.show()

"""**Scatter plot between credit amount and annuity amount**"""

fig = plt.figure(figsize=(10,8))
plt.scatter(combined_df[combined_df["TARGET"]==0]['AMT_ANNUITY_x'],combined_df[combined_df["TARGET"]==0]['AMT_CREDIT_x'],s=35,
            color="b",alpha=.5,label="REPAYER",linewidth=.5,edgecolor="k")
plt.scatter(combined_df[combined_df["TARGET"]==1]['AMT_ANNUITY_x'],combined_df[combined_df["TARGET"]==1]['AMT_CREDIT_x'],s=35,
            color="r",alpha=.2,label="DEFAULTER",linewidth=.5,edgecolor="k")
plt.legend(loc="best",prop={"size":15})
plt.xlabel("AMT_ANNUITY")
plt.ylabel("AMT_CREDIT")
plt.title("Scatter plot between credit amount and annuity amount")
plt.show()

"""**Pair Plot between amount variables**
* AMT_INCOME_TOTAL - Income of the client

* AMT_CREDIT - Credit amount of the loan

* AMT_ANNUITY - Loan annuity

* AMT_GOODS_PRICE - For consumer loans it is the price of the goods for which the loan is given
"""

amt = combined_df[[ 'AMT_INCOME_TOTAL','AMT_CREDIT_x',
                         'AMT_ANNUITY_x', 'AMT_GOODS_PRICE_x',"TARGET"]]
amt = amt[(amt["AMT_GOODS_PRICE_x"].notnull()) & (amt["AMT_ANNUITY_x"].notnull())]
sns.pairplot(amt,hue="TARGET",palette=["b","r"])
plt.show()

"""**Distribution of Suite type**
* NAME_TYPE_SUITE - Who was accompanying client when he was applying for the loan.
"""

plt.figure(figsize=(18,12))
plt.subplot(121)
sns.countplot(y=combined_df["NAME_TYPE_SUITE_x"],
              palette="Set2",
              order=combined_df["NAME_TYPE_SUITE_x"].value_counts().index[:5])
plt.title("Distribution of Suite type")

plt.subplot(122)
sns.countplot(y=combined_df["NAME_TYPE_SUITE_x"],
              hue=combined_df["CODE_GENDER"],palette="Set2",
              order=combined_df["NAME_TYPE_SUITE_x"].value_counts().index[:5])
plt.ylabel("")
plt.title("Distribution of Suite type by gender")
plt.subplots_adjust(wspace = .4)

"""**Distribution of client income type**
* NAME_INCOME_TYPE Clients income type (businessman, working, maternity leave,‚Ä¶)
"""

plt.figure(figsize=(18,12))
plt.subplot(121)
sns.countplot(y=combined_df["NAME_INCOME_TYPE"],
              palette="Set2",
              order=combined_df["NAME_INCOME_TYPE"].value_counts().index[:4])
plt.title("Distribution of client income type")

plt.subplot(122)
sns.countplot(y=combined_df["NAME_INCOME_TYPE"],
              hue=combined_df["CODE_GENDER"],
              palette="Set2",
              order=combined_df["NAME_INCOME_TYPE"].value_counts().index[:4])
plt.ylabel("")
plt.title("Distribution of client income  type by gender")
plt.subplots_adjust(wspace = .4)

"""**Distribution of Education type by loan repayment status**
* NAME_EDUCATION_TYPE Level of highest education the client achieved..
"""

plt.figure(figsize=(25,25))
plt.subplot(121)
combined_df[combined_df["TARGET"]==0]["NAME_EDUCATION_TYPE"].value_counts().plot.pie(fontsize=12,autopct = "%1.0f%%",
                                                                                                 colors = sns.color_palette("Set1"),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True)
circ = plt.Circle((0,0),.7,color="white")
plt.gca().add_artist(circ)
plt.title("Distribution of Education type for Repayers",color="b")

plt.subplot(122)
combined_df[combined_df["TARGET"]==1]["NAME_EDUCATION_TYPE"].value_counts().plot.pie(fontsize=12,autopct = "%1.0f%%",
                                                                                                 colors = sns.color_palette("Set1"),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True)
circ = plt.Circle((0,0),.7,color="white")
plt.gca().add_artist(circ)
plt.title("Distribution of Education type for Defaulters",color="b")
plt.ylabel("")
plt.show()

"""* Clients who default have proportionally 8% less higher education compared to clients who do not default.

**Average Earnings by different professions and education types**
"""

edu = combined_df.groupby(['NAME_EDUCATION_TYPE','NAME_INCOME_TYPE'])['AMT_INCOME_TOTAL'].mean().reset_index().sort_values(by='AMT_INCOME_TOTAL',ascending=False)
fig = plt.figure(figsize=(13,7))
ax = sns.barplot(x='NAME_INCOME_TYPE', y='AMT_INCOME_TOTAL',data=edu,hue='NAME_EDUCATION_TYPE',palette="seismic")
ax.set_facecolor("k")
plt.title(" Average Earnings by different professions and education types")
plt.show()

"""**Distribution of Education type by loan repayment status**
* NAME_FAMILY_STATUS - Family status of the client
"""

plt.figure(figsize=(16,8))
plt.subplot(121)
combined_df[combined_df["TARGET"]==0]["NAME_FAMILY_STATUS"].value_counts().plot.pie(autopct = "%1.0f%%",
                                                             startangle=120,colors = sns.color_palette("Set2",7),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True,explode=[0,.07,0,0,0])

plt.title("Distribution of Family status for Repayers",color="b")

plt.subplot(122)
combined_df[combined_df["TARGET"]==1]["NAME_FAMILY_STATUS"].value_counts().plot.pie(autopct = "%1.0f%%",
                                                    startangle=120,colors = sns.color_palette("Set2",7),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True,explode=[0,.07,0,0,0])


plt.title("Distribution of Family status for Defaulters",color="b")
plt.ylabel("")
plt.show()

"""* Percentage of single people are more in defaulters than non defaulters.

**Distribution of Housing type by loan repayment status**
* NAME_HOUSING_TYPE - What is the housing situation of the client (renting, living with parents, ...)
"""

plt.figure(figsize=(20,20))
plt.subplot(121)
combined_df[combined_df["TARGET"]==0]["NAME_HOUSING_TYPE"].value_counts().plot.pie(autopct = "%1.0f%%",fontsize=10,
                                                             colors = sns.color_palette("Spectral"),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True)

plt.title("Distribution of housing type  for Repayer",color="b")

plt.subplot(122)
combined_df[combined_df["TARGET"]==1]["NAME_HOUSING_TYPE"].value_counts().plot.pie(autopct = "%1.0f%%",fontsize=10,
                                                    colors = sns.color_palette("Spectral"),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True)


plt.title("Distribution of housing type for Defaulters",color="b")
plt.ylabel("")
plt.show()

"""**Distribution normalized population of region where client lives by loan repayment status**
* REGION_POPULATION_RELATIVE - Normalized population of region where client lives (higher number means the client lives in more populated region).
"""

fig = plt.figure(figsize=(13,8))

plt.subplot(121)
sns.violinplot(y=combined_df[combined_df["TARGET"]==0]["REGION_POPULATION_RELATIVE"]
               ,x=combined_df[combined_df["TARGET"]==0]["NAME_CONTRACT_TYPE_x"],
               palette="Set1")
plt.title("Distribution of region population for Non Default loans",color="b")
plt.subplot(122)
sns.violinplot(y = combined_df[combined_df["TARGET"]==1]["REGION_POPULATION_RELATIVE"]
               ,x=combined_df[combined_df["TARGET"]==1]["NAME_CONTRACT_TYPE_x"]
               ,palette="Set1")
plt.title("Distribution of region population  for  Default loans",color="b")

plt.subplots_adjust(wspace = .2)
fig.set_facecolor("lightgrey")

"""* In High population density regions people are less likely to default on loans.

**Client's age**
* DAYS_BIRTH - Client's age in days at the time of application.
"""

fig = plt.figure(figsize=(13,15))

plt.subplot(221)
sns.distplot(combined_df[combined_df["TARGET"]==0]["DAYS_BIRTH"],color="b")
plt.title("Age Distribution of repayers")

plt.subplot(222)
sns.distplot(combined_df[combined_df["TARGET"]==1]["DAYS_BIRTH"],color="r")
plt.title("Age Distribution of defaulters")

plt.subplot(223)
sns.boxplot(x=combined_df["TARGET"], y=combined_df["DAYS_BIRTH"],hue=combined_df["CODE_GENDER"],palette=["b","grey","m"])
plt.axhline(combined_df["DAYS_BIRTH"].mean(),linestyle="dashed",color="k",label ="average age of client")
plt.legend(loc="lower right")
plt.title("Client age vs Loan repayment status(hue=gender)")

plt.subplot(224)
sns.boxplot(x=combined_df["TARGET"], y=combined_df["DAYS_BIRTH"],hue=combined_df["NAME_CONTRACT_TYPE_x"],palette=["r","g"])
plt.axhline(combined_df["DAYS_BIRTH"].mean(),linestyle="dashed",color="k",label ="average age of client")
plt.legend(loc="lower right")
plt.title("Client age vs Loan repayment status(hue=contract type)")

plt.subplots_adjust(wspace = .2,hspace = .3)

fig.set_facecolor("lightgrey")

"""* Average clients age is comparatively less in non repayers than repayers in every aspect.

* Younger people tend to default more than elder people.

**Distribution of days employed for target variable.**
* DAYS_EMPLOYED - How many days before the application for target variable the person started current employment
"""

fig = plt.figure(figsize=(13,5))

plt.subplot(121)
sns.distplot(combined_df[combined_df["TARGET"]==0]["DAYS_EMPLOYED"],color="b")
plt.title("days employed distribution of repayers")

plt.subplot(122)
sns.distplot(combined_df[combined_df["TARGET"]==1]["DAYS_EMPLOYED"],color="r")
plt.title("days employed distribution of defaulters")

fig.set_facecolor("ghostwhite")

"""**Distribution of registration days for target variable.**
* DAYS_REGISTRATION How many days before the application did client change his registration
"""

fig = plt.figure(figsize=(13,5))

plt.subplot(121)
sns.distplot(combined_df[combined_df["TARGET"]==0]["DAYS_REGISTRATION"],color="b")
plt.title("registration days distribution of repayers")

plt.subplot(122)
sns.distplot(combined_df[combined_df["TARGET"]==1]["DAYS_REGISTRATION"],color="r")
plt.title("registration days distribution of defaulter")

fig.set_facecolor("ghostwhite")

"""**Distribution in contact information provided by client**
* FLAG_MOBIL - Did client provide mobile phone (1=YES, 0=NO)

* FLAG_EMP_PHONE - Did client provide work phone (1=YES, 0=NO)

* FLAG_WORK_PHONE - Did client provide home phone (1=YES, 0=NO)

* FLAG_CONT_MOBILE - Was mobile phone reachable (1=YES, 0=NO)

* FLAG_PHONE - Did client provide home phone (1=YES, 0=NO)

* FLAG_EMAIL - Did client provide email (1=YES, 0=NO)
"""

x   = combined_df[['FLAG_MOBIL', 'FLAG_EMP_PHONE', 'FLAG_WORK_PHONE', 'FLAG_CONT_MOBILE',
       'FLAG_PHONE', 'FLAG_EMAIL',"TARGET"]]
x["TARGET"] = x["TARGET"].replace({0:"repayers",1:"defaulters"})
x  = x.replace({1:"YES",0:"NO"})

cols = ['FLAG_MOBIL', 'FLAG_EMP_PHONE', 'FLAG_WORK_PHONE', 'FLAG_CONT_MOBILE',
       'FLAG_PHONE', 'FLAG_EMAIL']
length = len(cols)

fig = plt.figure(figsize=(15,12))
fig.set_facecolor("lightgrey")

for i,j in itertools.zip_longest(cols,range(length)):
    plt.subplot(2,3,j+1)
    sns.countplot(x=x[i],hue=x["TARGET"],palette=["r","g"])
    plt.title(i,color="b")

"""**Distribution of registration days for target variable.**
* REGION_RATING_CLIENT - Home credit rating of the region where client lives (1,2,3).

* REGION_RATING_CLIENT_W_CITY - Home credit rating of the region where client lives with taking city into account (1,2,3). Percentage of defaulters are less in 1-rated regions compared to repayers.
"""

fig = plt.figure(figsize=(13,13))
plt.subplot(221)
combined_df[combined_df["TARGET"]==0]["REGION_RATING_CLIENT"].value_counts().plot.pie(autopct = "%1.0f%%",fontsize=12,
                                                             colors = sns.color_palette("Pastel1"),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True)

plt.title("Distribution of region rating  for Repayers",color="b")

plt.subplot(222)
combined_df[combined_df["TARGET"]==1]["REGION_RATING_CLIENT"].value_counts().plot.pie(autopct = "%1.0f%%",fontsize=12,
                                                    colors = sns.color_palette("Pastel1"),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True)


plt.title("Distribution of region rating  for Defaulters",color="b")
plt.ylabel("")

plt.subplot(223)
combined_df[combined_df["TARGET"]==0]["REGION_RATING_CLIENT_W_CITY"].value_counts().plot.pie(autopct = "%1.0f%%",fontsize=12,
                                                             colors = sns.color_palette("Paired"),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True)

plt.title("Distribution of city region rating   for Repayers",color="b")

plt.subplot(224)
combined_df[combined_df["TARGET"]==1]["REGION_RATING_CLIENT_W_CITY"].value_counts().plot.pie(autopct = "%1.0f%%",fontsize=12,
                                                    colors = sns.color_palette("Paired"),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True)


plt.title("Distribution of city region rating  for Defaulters",color="b")
plt.ylabel("")
fig.set_facecolor("ivory")

"""* Percentage of defaulters are less in 1-rated regions compared to repayers.

* Percentage of defaulters are more in 3-rated regions compared to repayers.

**Distribution in organization types for repayers and defaulters**
* ORGANIZATION_TYPE - Type of organization where client works.
"""

org = combined_df.groupby("TARGET").agg({"ORGANIZATION_TYPE":"value_counts"})
org = org.rename(columns = {"ORGANIZATION_TYPE":"value_counts"}).reset_index()
org_0 = org[org["TARGET"] == 0]
org_1 = org[org["TARGET"] == 1]
org_0["percentage"] = org_0["value_counts"]*100/org_0["value_counts"].sum()
org_1["percentage"] = org_1["value_counts"]*100/org_1["value_counts"].sum()

organization = pd.concat([org_0,org_1],axis=0)
organization = organization.sort_values(by="ORGANIZATION_TYPE",ascending=True)

organization["TARGET"] = organization["TARGET"].replace({0:"repayers",1:"defaulters"})

organization
plt.figure(figsize=(13,7))
ax = sns.pointplot(x="ORGANIZATION_TYPE", y="percentage",
                   data=organization,hue="TARGET",palette=["b","r"])
plt.xticks(rotation=90)
plt.grid(True,alpha=.3)
ax.set_facecolor("k")
ax.set_title("Distribution in organization types for repayers and defaulters")
plt.show()

"""* Organizations like Business Entity Type 3,Construction,Self-employed percentage of defaulters are higher than repayers.

**Distribution client's social surroundings with observed and defaulted 30 DPD (days past due)**
* OBS_30_CNT_SOCIAL_CIRCLE- How many observation of client's social surroundings with observable 30 DPD (days past due) default.

* DEF_30_CNT_SOCIAL_CIRCLE-How many observation of client's social surroundings defaulted on 30 DPD (days past due) .

* OBS_60_CNT_SOCIAL_CIRCLE - How many observation of client's social surroundings with observable 60 DPD (days past due) default.

* DEF_60_CNT_SOCIAL_CIRCLE - How many observation of client's social surroundings defaulted on 60 (days past due) DPD.
"""

fig = plt.figure(figsize=(20,20))
plt.subplot(421)
sns.boxplot(data=combined_df,x='TARGET',y='OBS_30_CNT_SOCIAL_CIRCLE',
            hue="TARGET", palette="Set3")
plt.title("Client's social surroundings with observable 30 DPD (days past due) def",color="b")
plt.subplot(422)
sns.boxplot(data=combined_df,x='TARGET',y='DEF_30_CNT_SOCIAL_CIRCLE',
            hue="TARGET", palette="Set3")
plt.title("Client's social surroundings defaulted on 30 DPD (days past due)",color="b")
plt.subplot(423)
sns.boxplot(data=combined_df,x='TARGET',y='OBS_60_CNT_SOCIAL_CIRCLE',
            hue="TARGET", palette="Set3")
plt.title("Client's social surroundings with observable 60 DPD (days past due) default",color="b")
plt.subplot(424)
sns.boxplot(data=combined_df,x='TARGET',y='DEF_60_CNT_SOCIAL_CIRCLE',
            hue="TARGET", palette="Set3")
plt.title("Client's social surroundings defaulted on 60 DPD (days past due)",color="b")
fig.set_facecolor("ghostwhite")

"""**Number of days before application client changed phone .**
* DAYS_LAST_PHONE_CHANGE - How many days before application did client change phone.
"""

plt.figure(figsize=(13,7))
plt.subplot(121)
ax = sns.violinplot(x=combined_df["TARGET"],
                    y=combined_df["DAYS_LAST_PHONE_CHANGE"],palette=["g","r"])
ax.set_facecolor("oldlace")
ax.set_title("days before application client changed phone -violin plot")
plt.subplot(122)
ax1 = sns.boxplot(x=combined_df["TARGET"],
                 y=combined_df["DAYS_LAST_PHONE_CHANGE"],palette=["g","r"])
ax1.set_facecolor("oldlace")
ax1.set_ylabel("")
ax1.set_title("days before application client changed phone -box plot")
plt.subplots_adjust(wspace = .2)

"""* Average days of defaulters phone change is less than average days of repayers phone change.

**Documents provided by the clients.**
* FLAG_DOCUMENT - Did client provide documents.(1,0)
"""

cols = [ 'FLAG_DOCUMENT_2', 'FLAG_DOCUMENT_3',
       'FLAG_DOCUMENT_4', 'FLAG_DOCUMENT_5', 'FLAG_DOCUMENT_6',
       'FLAG_DOCUMENT_7', 'FLAG_DOCUMENT_8', 'FLAG_DOCUMENT_9',
       'FLAG_DOCUMENT_10', 'FLAG_DOCUMENT_11', 'FLAG_DOCUMENT_12',
       'FLAG_DOCUMENT_13', 'FLAG_DOCUMENT_14', 'FLAG_DOCUMENT_15',
       'FLAG_DOCUMENT_16', 'FLAG_DOCUMENT_17', 'FLAG_DOCUMENT_18',
       'FLAG_DOCUMENT_19', 'FLAG_DOCUMENT_20', 'FLAG_DOCUMENT_21']

df_flag = combined_df[cols+["TARGET"]]

length = len(cols)

df_flag["TARGET"] = df_flag["TARGET"].replace({1:"defaulter",0:"repayer"})

fig = plt.figure(figsize=(13,24))
fig.set_facecolor("lightgrey")
for i,j in itertools.zip_longest(cols,range(length)):
    plt.subplot(5,4,j+1)
    ax = sns.countplot(x=df_flag[i],hue=df_flag["TARGET"],palette=["r","b"])
    plt.yticks(fontsize=5)
    plt.xlabel("")
    plt.title(i)
    ax.set_facecolor("k")

"""**Equiries to Credit Bureau about the client before application.**
* AMT_REQ_CREDIT_BUREAU_HOUR - Number of enquiries to Credit Bureau about the client one hour before application.

* AMT_REQ_CREDIT_BUREAU_DAY - Number of enquiries to Credit Bureau about the client one day before application (excluding one hour before application).

* AMT_REQ_CREDIT_BUREAU_WEEK - Number of enquiries to Credit Bureau about the client one week before application (excluding one day before application).

* AMT_REQ_CREDIT_BUREAU_MON - Number of enquiries to Credit Bureau about the client one month before application (excluding one week before application).

* AMT_REQ_CREDIT_BUREAU_QRT - Number of enquiries to Credit Bureau about the client 3 month before application (excluding one month before application).

* AMT_REQ_CREDIT_BUREAU_YEAR - Number of enquiries to Credit Bureau about the client one day year (excluding last 3 months before application).
"""

cols = ['AMT_REQ_CREDIT_BUREAU_HOUR', 'AMT_REQ_CREDIT_BUREAU_DAY',
       'AMT_REQ_CREDIT_BUREAU_WEEK', 'AMT_REQ_CREDIT_BUREAU_MON',
       'AMT_REQ_CREDIT_BUREAU_QRT', 'AMT_REQ_CREDIT_BUREAU_YEAR']
combined_df.groupby("TARGET")[cols].max().transpose().plot(kind="barh",
                                                                 figsize=(10,5),width=.8)
plt.title("Maximum enquries made by defaulters and repayers")
combined_df.groupby("TARGET")[cols].mean().transpose().plot(kind="barh",
                                                                  figsize=(10,5),width=.8)
plt.title("average enquries made by defaulters and repayers")
combined_df.groupby("TARGET")[cols].std().transpose().plot(kind="barh",
                                                                 figsize=(10,5),width=.8)
plt.title("standard deviation in enquries made by defaulters and repayers")
plt.show()

"""**Contract types collected from previous applications**
* NAME_CONTRACT_TYPE Contract product type (Cash loan, consumer loan [POS] ,...) of the previous application.
"""

cnts = combined_df["NAME_CONTRACT_TYPE_y"].value_counts()
import squarify
plt.figure(figsize=(8,6))
squarify.plot(cnts.values,label=cnts.keys(),value=cnts.values,linewidth=2,edgecolor="k",alpha=.8,color=sns.color_palette("Set1"))
plt.axis("off")
plt.title("Contaract types collected from previous applications")
plt.show()

"""* Consumer loan applications are maximum followed by cash loan applications in previous loan.

**Previous loan amounts applied and loan amounts credited.**
* AMT_APPLICATION-For how much credit did client ask on the previous application.

* AMT_CREDIT-Final credit amount on the previous application. This differs from * AMT_APPLICATION in a way that the AMT_APPLICATION is the amount for which the client initially applied for, but during our approval process he could have received different amount - AMT_CREDIT.
"""

plt.figure(figsize=(20,20))
plt.subplot(211)
ax = sns.kdeplot(combined_df["AMT_APPLICATION"],color="b",linewidth=3)
ax = sns.kdeplot(combined_df[combined_df["AMT_CREDIT_y"].notnull()]["AMT_CREDIT_y"],color="r",linewidth=3)
plt.axvline(combined_df[combined_df["AMT_CREDIT_y"].notnull()]["AMT_CREDIT_y"].mean(),color="r",linestyle="dashed",label="AMT_APPLICATION_MEAN")
plt.axvline(combined_df["AMT_APPLICATION"].mean(),color="b",linestyle="dashed",label="AMT_APPLICATION_MEAN")
plt.legend(loc="best")
plt.title("Previous loan amounts applied and loan amounts credited.")
ax.set_facecolor("k")

plt.subplot(212)
diff = (combined_df["AMT_CREDIT_y"] - combined_df["AMT_APPLICATION"]).reset_index()
diff = diff[diff[0].notnull()]
ax1 = sns.kdeplot(diff[0],color="g",linewidth=3,label = "difference in amount requested by client and amount credited")
plt.axvline(diff[0].mean(),color="white",linestyle="dashed",label = "mean")
plt.title("difference in amount requested by client and amount credited")
ax1.legend(loc="best")
ax1.set_facecolor("k")

"""**Total and average amounts applied and credited in previous applications**
* AMT_APPLICATION-For how much credit did client ask on the previous application. >AMT_CREDIT-Final credit amount on the previous application. This differs from AMT_APPLICATION in a way that the AMT_APPLICATION is the amount for which the client.
"""

mn = combined_df.groupby("NAME_CONTRACT_TYPE_y")[["AMT_APPLICATION","AMT_CREDIT_y"]].mean().stack().reset_index()
tt = combined_df.groupby("NAME_CONTRACT_TYPE_y")[["AMT_APPLICATION","AMT_CREDIT_y"]].sum().stack().reset_index()
fig = plt.figure(figsize=(10,13))
fig.set_facecolor("ghostwhite")
plt.subplot(211)
ax = sns.barplot(x=0, y="NAME_CONTRACT_TYPE_y",data=mn[:6],hue="level_1",palette="inferno")
ax.set_facecolor("k")
ax.set_xlabel("average amounts")
ax.set_title("Average amounts by contract types")

plt.subplot(212)
ax1 = sns.barplot(x=0, y="NAME_CONTRACT_TYPE_y",data=tt[:6],hue="level_1",palette="magma")
ax1.set_facecolor("k")
ax1.set_xlabel("total amounts")
ax1.set_title("total amounts by contract types")
plt.subplots_adjust(hspace = .2)
plt.show()

"""**Annuity of previous application**
* AMT_ANNUITY - Annuity of previous application
"""

plt.figure(figsize=(14,5))
plt.subplot(121)
combined_df.groupby("NAME_CONTRACT_TYPE_y")["AMT_ANNUITY_y"].sum().plot(kind="bar")
plt.xticks(rotation=0)
plt.title("Total annuity amount by contract types in previous applications")
plt.subplot(122)
combined_df.groupby("NAME_CONTRACT_TYPE_y")["AMT_ANNUITY_y"].mean().plot(kind="bar")
plt.title("average annuity amount by contract types in previous applications")
plt.xticks(rotation=0)
plt.show()

"""**Count of application status by application type.**
* NAME_CONTRACT_TYPE -Contract product type (Cash loan, consumer loan [POS] ,...) of the previous application.

* NAME_CONTRACT_STATUS -Contract status (approved, cancelled, ...) of previous application.
"""

ax = pd.crosstab(combined_df["NAME_CONTRACT_TYPE_y"],combined_df["NAME_CONTRACT_STATUS"]).plot(kind="barh",figsize=(10,7),stacked=True)
plt.xticks(rotation =0)
plt.ylabel("count")
plt.title("Count of application status by application type")
ax.set_facecolor("k")

"""* Consumer loan applications are most approved loans and cash loans are most cancelled and refused loans.

**Contract status by weekdays**
* WEEKDAY_APPR_PROCESS_START - On which day of the week did the client apply for previous application
"""

hr = pd.crosstab(combined_df["WEEKDAY_APPR_PROCESS_START_x"],combined_df["NAME_CONTRACT_STATUS"]).stack().reset_index()
plt.figure(figsize=(12,8))
ax = sns.pointplot(x=hr["WEEKDAY_APPR_PROCESS_START_x"],y=hr[0],hue=hr["NAME_CONTRACT_STATUS"],palette=["g","r","b","orange"],scale=1)
ax.set_facecolor("k")
ax.set_ylabel("count")
ax.set_title("Contract status by weekdays")
plt.grid(True,alpha=.2)

"""**Contract status by hour of the day**
* HOUR_APPR_PROCESS_START - Approximately at what day hour did the client apply for the previous application.
"""

hr = pd.crosstab(combined_df["HOUR_APPR_PROCESS_START_x"],combined_df["NAME_CONTRACT_STATUS"]).stack().reset_index()
plt.figure(figsize=(12,8))
ax = sns.pointplot(x=hr["HOUR_APPR_PROCESS_START_x"], y=hr[0],hue=hr["NAME_CONTRACT_STATUS"],palette=["g","r","b","orange"],scale=1)
ax.set_facecolor("k")
ax.set_ylabel("count")
ax.set_title("Contract status by day hours.")
plt.grid(True,alpha=.2)

"""* Morning 10'o clock have maximum number of approvals.

* Morning 10'o clock have maximum number of refused and cancelled contracts.

**Peak hours for week days for applying loans**
"""

hr = pd.crosstab(combined_df["HOUR_APPR_PROCESS_START_x"],combined_df["WEEKDAY_APPR_PROCESS_START_x"]).stack().reset_index()
plt.figure(figsize=(12,8))
ax = sns.pointplot(x=hr["HOUR_APPR_PROCESS_START_x"], y=hr[0],hue=hr["WEEKDAY_APPR_PROCESS_START_x"],palette=["g","r","b","orange"],scale=1)
ax.set_facecolor("k")
ax.set_ylabel("count")
ax.set_title("Peak hours for week days")
plt.grid(True,alpha=.2)

"""**Percentage of applications accepted,cancelled,refused and unused for different loan purposes.**
* NAME_CASH_LOAN_PURPOSE - Purpose of the cash loan.

* NAME_CONTRACT_STATUS - Contract status (approved, cancelled, ...) of previous application.
"""

combined_df[["NAME_CASH_LOAN_PURPOSE","NAME_CONTRACT_STATUS"]]
purpose = pd.crosstab(combined_df["NAME_CASH_LOAN_PURPOSE"],combined_df["NAME_CONTRACT_STATUS"])
purpose["a"] = (purpose["Approved"]*100)/(purpose["Approved"]+purpose["Canceled"]+purpose["Refused"]+purpose["Unused offer"])
purpose["c"] = (purpose["Canceled"]*100)/(purpose["Approved"]+purpose["Canceled"]+purpose["Refused"]+purpose["Unused offer"])
purpose["r"] = (purpose["Refused"]*100)/(purpose["Approved"]+purpose["Canceled"]+purpose["Refused"]+purpose["Unused offer"])
purpose["u"] = (purpose["Unused offer"]*100)/(purpose["Approved"]+purpose["Canceled"]+purpose["Refused"]+purpose["Unused offer"])
purpose_new = purpose[["a","c","r","u"]]
purpose_new = purpose_new.stack().reset_index()
purpose_new["NAME_CONTRACT_STATUS"] = purpose_new["NAME_CONTRACT_STATUS"].replace({"a":"accepted_percentage","c":"cancelled_percentage",
                                                               "r":"refused_percentage","u":"unused_percentage"})

lst = purpose_new["NAME_CONTRACT_STATUS"].unique().tolist()
length = len(lst)
cs = ["lime","orange","r","b"]

fig = plt.figure(figsize=(14,18))
fig.set_facecolor("lightgrey")
for i,j,k in itertools.zip_longest(lst,range(length),cs):
    plt.subplot(2,2,j+1)
    dat = purpose_new[purpose_new["NAME_CONTRACT_STATUS"] == i]
    ax = sns.barplot(x=0, y="NAME_CASH_LOAN_PURPOSE",data=dat.sort_values(by=0,ascending=False),color=k)
    plt.ylabel("")
    plt.xlabel("percentage")
    plt.title(i+" by purpose")
    plt.subplots_adjust(wspace = .7)
    ax.set_facecolor("k")

"""* Purposes like XAP ,electronic eqipment ,everey day expences and education have maximum loan acceptance.

* Loan puposes like Hobby, payment of other loans ,refusal to name goal ,buying new home or car have most refusals.

* 37.5% of XNA purpose loans are cancalled.

**Contract status relative to decision made about previous application.**
* DAYS_DECISION - Relative to current application when was the decision about previous application made.
"""

plt.figure(figsize=(13,6))
sns.violinplot(y= combined_df["DAYS_DECISION"],
               x = combined_df["NAME_CONTRACT_STATUS"],palette=["r","g","b","y"])
plt.axhline(combined_df[combined_df["NAME_CONTRACT_STATUS"] == "Approved"]["DAYS_DECISION"].mean(),
            color="r",linestyle="dashed",label="accepted_average")
plt.axhline(combined_df[combined_df["NAME_CONTRACT_STATUS"] == "Refused"]["DAYS_DECISION"].mean(),
            color="g",linestyle="dashed",label="refused_average")
plt.axhline(combined_df[combined_df["NAME_CONTRACT_STATUS"] == "Cancelled"]["DAYS_DECISION"].mean(),color="b",
            linestyle="dashed",label="cancelled_average")
plt.axhline(combined_df[combined_df["NAME_CONTRACT_STATUS"] == "Unused offer"]["DAYS_DECISION"].mean(),color="y",
            linestyle="dashed",label="un used_average")
plt.legend(loc="best")

plt.title("Contract status relative to decision made about previous application.")
plt.show()

"""* On average approved contract types have higher number of decision days compared to cancelled and refused contracts.

**Client payment methods & reasons for application rejections**
* NAME_PAYMENT_TYPE - Payment method that client chose to pay for the previous application.

* CODE_REJECT_REASON - Why was the previous application rejected.
"""

plt.figure(figsize=(8, 12))

# First subplot
plt.subplot(211)
rej = combined_df["CODE_REJECT_REASON"].value_counts().reset_index()
rej.columns = ["CODE_REJECT_REASON", "count"]

ax = sns.barplot(x="count", y="CODE_REJECT_REASON", data=rej[:6], palette="husl")

for i, j in enumerate(np.around((rej["count"][:6].values * 100 / rej["count"][:6].sum()), 1)):
    ax.text(rej["count"].max() * 0.7, i, f"{j}%", weight="bold")

plt.xlabel("Count")
plt.ylabel("CODE_REJECT_REASON")
plt.title("Reasons for application rejections")

# Second subplot
plt.subplot(212)
pay = combined_df["NAME_PAYMENT_TYPE"].value_counts().reset_index()
pay.columns = ["NAME_PAYMENT_TYPE", "count"]

ax1 = sns.barplot(x="count", y="NAME_PAYMENT_TYPE", data=pay, palette="husl")

for i, j in enumerate(np.around((pay["count"].values * 100 / pay["count"].sum()), 1)):
    ax1.text(pay["count"].max() * 0.7, i, f"{j}%", weight="bold")

plt.xlabel("Count")
plt.ylabel("NAME_PAYMENT_TYPE")
plt.title("Clients payment methods")

plt.subplots_adjust(hspace=0.3)
plt.show()

plt.figure(figsize=(8,12))
plt.subplot(211)
rej = combined_df["CODE_REJECT_REASON"].value_counts().reset_index()
ax = sns.barplot(x="CODE_REJECT_REASON", y="index", data=rej[:6], palette="husl")

for i,j in enumerate(np.around((rej["CODE_REJECT_REASON"][:6].values*100/(rej["CODE_REJECT_REASON"][:6].sum())))):
    ax.text(.7,i,j,weight="bold")
plt.xlabel("percentage")
plt.ylabel("CODE_REJECT_REASON")
plt.title("Reasons for application rejections")

plt.subplot(212)
pay = combined_df["NAME_PAYMENT_TYPE"].value_counts().reset_index()
ax1 = sns.barplot("NAME_PAYMENT_TYPE","index",data=pay,palette="husl")
for i,j in enumerate(np.around((pay["NAME_PAYMENT_TYPE"].values*100/(pay["NAME_PAYMENT_TYPE"].sum())))):
    ax1.text(.7,i,j,weight="bold")
plt.xlabel("percentage")
plt.ylabel("NAME_PAYMENT_TYPE")
plt.title("Clients payment methods")
plt.subplots_adjust(hspace = .3)

"""* Around 87% of rejected applications the reason is XAP.

* 67% of chose to pay through cash by bank for previous applications.

**Distribution in Client suite type & client type.**
* NAME_TYPE_SUITE - Who accompanied client when applying for the previous application.

* NAME_CLIENT_TYPE - Was the client old or new client when applying for the previous application.
"""

plt.figure(figsize=(20,20))
plt.subplot(121)
combined_df["NAME_TYPE_SUITE_x"].value_counts().plot.pie(autopct = "%1.1f%%",fontsize=12,
                                                             colors = sns.color_palette("inferno"),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True)
circ = plt.Circle((0,0),.7,color="white")
plt.gca().add_artist(circ)
plt.title("NAME_TYPE_SUITE")

plt.subplot(122)
combined_df["NAME_CLIENT_TYPE"].value_counts().plot.pie(autopct = "%1.1f%%",fontsize=12,
                                                             colors = sns.color_palette("inferno"),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True)
circ = plt.Circle((0,0),.7,color="white")
plt.gca().add_artist(circ)
plt.title("NAME_CLIENT_TYPE")
plt.show()

"""* About 81.2% clients are un-accompained when applying for loans.

* 55.4% clients are old clients

**Popular goods for applying loans**
* NAME_GOODS_CATEGORY - What kind of goods did the client apply for in the previous application.
"""

goods = combined_df["NAME_GOODS_CATEGORY"].value_counts().reset_index()
goods.columns = ["NAME_GOODS_CATEGORY", "count"]
goods["percentage"] = round(goods["count"] * 100 / goods["count"].sum(), 2)

fig = plt.figure(figsize=(12, 5))
ax = sns.pointplot(x="NAME_GOODS_CATEGORY", y="percentage", data=goods, color="yellow")

plt.xticks(rotation=80)
plt.xlabel("NAME_GOODS_CATEGORY")
plt.ylabel("Percentage")
plt.title("Popular goods for applying loans")

ax.set_facecolor("k")
fig.set_facecolor("lightgrey")
plt.show()

"""* XNA ,Mobiles ,Computers and consumer electronics are popular goods for applying loans"""

plt.figure(figsize=(20,20))
plt.subplot(121)
combined_df["NAME_PORTFOLIO"].value_counts().plot.pie(autopct = "%1.1f%%",fontsize=12,
                                                             colors = sns.color_palette("prism",5),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},
                                                               shadow =True)
plt.title("previous applications portfolio")
plt.subplot(122)
combined_df["NAME_PRODUCT_TYPE"].value_counts().plot.pie(autopct = "%1.1f%%",fontsize=12,
                                                             colors = sns.color_palette("prism",3),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},
                                                                  shadow =True)
plt.title("previous applications product types")
plt.show()

"""**Approval,canceled and refusal rates by channel types.**
* CHANNEL_TYPE - Through which channel we acquired the client on the previous application.

* NAME_CONTRACT_STATUS- Contract status (approved, cancelled, ...) of previous application.
"""

app = pd.crosstab(combined_df["CHANNEL_TYPE"],combined_df["NAME_CONTRACT_STATUS"])
app1 = app
app1["approval_rate"] = app1["Approved"]*100/(app1["Approved"]+app1["Refused"]+app1["Canceled"])
app1["refused_rate"]  = app1["Refused"]*100/(app1["Approved"]+app1["Refused"]+app1["Canceled"])
app1["cacelled_rate"] = app1["Canceled"]*100/(app1["Approved"]+app1["Refused"]+app1["Canceled"])
app2 = app[["approval_rate","refused_rate","cacelled_rate"]]
ax = app2.plot(kind="barh",stacked=True,figsize=(10,7))
ax.set_facecolor("k")
ax.set_xlabel("percentage")
ax.set_title("approval,cancel and refusal rates by channel types")
plt.show()

"""* Channel types like Stone ,regional and country-wide have maximum approval rates.

* Channel of coorporate sales have maximum refusal rate.

* Credit-cash centres and Contact centres have maximum cancellation rates.

**Highest amount credited seller areas and industries.**
* SELLERPLACE_AREA - Selling area of seller place of the previous application.

* NAME_SELLER_INDUSTRY - The industry of the seller.
"""

fig = plt.figure(figsize=(13,5))
plt.subplot(121)
are = combined_df.groupby("SELLERPLACE_AREA")["AMT_CREDIT_y"].sum().reset_index()
are = are.sort_values(by ="AMT_CREDIT_y",ascending = False)
ax = sns.barplot(y= "AMT_CREDIT_y",x ="SELLERPLACE_AREA",data=are[:15],color="r")
ax.set_facecolor("k")
ax.set_title("Highest amount credited seller place areas")

plt.subplot(122)
sell = combined_df.groupby("NAME_SELLER_INDUSTRY")["AMT_CREDIT_y"].sum().reset_index().sort_values(by = "AMT_CREDIT_y",ascending = False)
ax1=sns.barplot(y = "AMT_CREDIT_y",x = "NAME_SELLER_INDUSTRY",data=sell,color="b")
ax1.set_facecolor("k")
ax1.set_title("Highest amount credited seller industrys")
plt.xticks(rotation=90)
plt.subplots_adjust(wspace = .5)
fig.set_facecolor("lightgrey")

"""**Popular terms of previous credit at application**.
* CNT_PAYMENT - Term of previous credit at application of the previous application.
"""

plt.figure(figsize=(13,5))
ax = sns.countplot(combined_df["CNT_PAYMENT"],palette="Set1",order=combined_df["CNT_PAYMENT"].value_counts().index)
ax.set_facecolor("k")
plt.xticks(rotation = 90)
plt.title("popular terms of previous credit at application")
plt.show()

"""* Popular term of previous credit are 6months ,10months ,1year ,2years & 3 years.
**Detailed product combination of the previous application**


"""

plt.figure(figsize=(10,8))
sns.countplot(y = combined_df["PRODUCT_COMBINATION"],order=combined_df["PRODUCT_COMBINATION"].value_counts().index)
plt.title("Detailed product combination of the previous application -count")
plt.show()

"""**Frequency distribution of intrest rates and client insurance requests**¬∂
* NAME_YIELD_GROUP - Grouped interest rate into small medium and high of the previous application.

* NFLAG_INSURED_ON_APPROVAL - Did the client requested insurance during the previous application.
"""

plt.figure(figsize=(12,6))
plt.subplot(121)
combined_df["NFLAG_INSURED_ON_APPROVAL"].value_counts().plot.pie(autopct = "%1.1f%%",fontsize=8,
                                                             colors = sns.color_palette("prism",4),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True)
circ = plt.Circle((0,0),.7,color="white")
plt.gca().add_artist(circ)
plt.title("client requesting insurance")

plt.subplot(122)
combined_df["NAME_YIELD_GROUP"].value_counts().plot.pie(autopct = "%1.1f%%",fontsize=8,
                                                             colors = sns.color_palette("prism",4),
                                              wedgeprops={"linewidth":2,"edgecolor":"white"},shadow =True)
circ = plt.Circle((0,0),.7,color="white")
plt.gca().add_artist(circ)
plt.title("interest rates")
plt.show()

"""**Days variables - Relative to application date of current application**
* DAYS_FIRST_DRAWING - Relative to application date of current application when was the first disbursement of the previous application.

* DAYS_FIRST_DUE - Relative to application date of current application when was the first due supposed to be of the previous application.

*DAYS_LAST_DUE_1ST_VERSION - Relative to application date of current application when was the first due of the previous application.

* DAYS_LAST_DUE -Relative to application date of current application when was the last due date of the previous application.

* DAYS_TERMINATION - Relative to application date of current application when was the expected termination of the previous application.
"""

cols = ['DAYS_FIRST_DRAWING', 'DAYS_FIRST_DUE', 'DAYS_LAST_DUE_1ST_VERSION','DAYS_LAST_DUE', 'DAYS_TERMINATION']
plt.figure(figsize=(12,6))
sns.heatmap(combined_df[cols].describe()[1:].transpose(),
            annot=True,linewidth=2,linecolor="k",cmap=sns.color_palette("inferno"))
plt.show()

"""**Top 10 Correlation Fields for Repayer**"""

corrmat = df_repayer.corr()
corrdf = corrmat.where(np.triu(np.ones(corrmat.shape), k=1).astype(np.bool))
corrdf = corrdf.unstack().reset_index()
corrdf.columns = ['Var1', 'Var2', 'Correlation']
corrdf.dropna(subset = ['Correlation'], inplace = True)
corrdf['Correlation'] = round(corrdf['Correlation'], 2)
corrdf['Correlation'] = abs(corrdf['Correlation'])
corrdf.sort_values(by = 'Correlation', ascending = False).head(10)

corrmat = df_defaulter.corr()
corrdf = corrmat.where(np.triu(np.ones(corrmat.shape), k=1).astype(np.bool))
corrdf = corrdf.unstack().reset_index()
corrdf.columns = ['Var1', 'Var2', 'Correlation']
corrdf.dropna(subset = ['Correlation'], inplace = True)
corrdf['Correlation'] = round(corrdf['Correlation'], 2)
corrdf['Correlation'] = abs(corrdf['Correlation'])
corrdf.sort_values(by = 'Correlation', ascending = False).head(10)

import pandas as pd
import numpy as np
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import cross_val_score, StratifiedKFold
from sklearn.linear_model import LogisticRegression
import seaborn as sns
import matplotlib.pyplot as plt



# Nettoyage
application_data_clean = application_data.dropna(subset=['TARGET'])
X = application_data_clean.select_dtypes(include=[np.number]).drop(columns=['TARGET'], errors='ignore')
y = application_data_clean['TARGET']

# Supprimer colonnes avec trop de NaNs ou constantes
X = X.dropna(axis=1, thresh=int(0.9 * len(X)))
X = X.loc[:, X.nunique() > 1]
X = X.fillna(X.median())

# Standardisation
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# ACP (95% variance)
pca = PCA(n_components=0.95)
X_pca = pca.fit_transform(X_scaled)

# Afficher la variance expliqu√©e
print("Variance expliqu√©e par les 10 premi√®res composantes :")
print(pca.explained_variance_ratio_[:10])

# Cross-validation avec r√©gression logistique
cv = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)
model = LogisticRegression(max_iter=1000)
scores = cross_val_score(model, X_pca, y, cv=cv, scoring='roc_auc')

print(f"\nROC AUC moyen : {scores.mean():.4f} ¬± {scores.std():.4f}")

# Corr√©lation entre les variables num√©riques et la cible
correlations = application_data_clean.corr(numeric_only=True)['TARGET'].drop('TARGET').sort_values(key=abs, ascending=False)
print("\nTop corr√©lations avec la cible TARGET :")
print(correlations.head(10))




# Heatmap des 10 plus corr√©l√©es
top_corr_features = correlations.head(10).index.tolist()
plt.figure(figsize=(10, 6))
sns.heatmap(application_data_clean[top_corr_features + ['TARGET']].corr(), annot=True, cmap='coolwarm')
plt.title("üî∂ Corr√©lation entre TARGET et les features principales")
plt.show()

# 5. Standardisation
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# 6. ACP
pca = PCA(n_components=0.95)  # garde 95% de la variance
X_pca = pca.fit_transform(X_scaled)
print(f"\n‚úÖ Nombre de composantes retenues : {pca.n_components_}")

# Scree plot
plt.figure(figsize=(10, 5))
plt.plot(np.cumsum(pca.explained_variance_ratio_), marker='o')
plt.xlabel('Nombre de composantes')
plt.ylabel('Variance expliqu√©e cumul√©e')
plt.title('üìâ Scree Plot - Variance expliqu√©e par l‚ÄôACP')
plt.grid()
plt.show()

# 7. Cross-validation
cv = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)
model = LogisticRegression(max_iter=1000)
scores = cross_val_score(model, X_pca, y, cv=cv, scoring='roc_auc')
print(f"\nüìà ROC AUC moyen (cross-validation) : {scores.mean():.4f} ¬± {scores.std():.4f}")

# 8. Matrice de confusion
X_train, X_test, y_train, y_test = train_test_split(X_pca, y, test_size=0.2, stratify=y, random_state=42)
model.fit(X_train, y_train)
y_pred = model.predict(X_test)
cm = confusion_matrix(y_test, y_pred)
disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=['Cr√©dit OK', 'Cr√©dit Risqu√©'])
disp.plot(cmap='Blues')
plt.title("üß© Matrice de confusion - R√©gression logistique")
plt.show()





















